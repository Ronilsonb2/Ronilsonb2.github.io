
/ *! jQuery v1.11.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license * /
! function (a, b) {"objeto" == tipo de módulo && "objeto" == tipo de módulo.exportação? módulo.exportação = a.documento? b (a,! 0): função (a) {if (! a .document) throw new Error ("jQuery requer uma janela com um documento"); retorne b (a)}: b (a)} ("indefinido"! = tipo de janela? window: this, function (a, b) { var c = [], d = c.slice, e = c.concat, f = c.push, g = c.indexOf, h = {}, i = h.toString, j = h.hasOwnProperty, k = " ".trim, l = {}, m =" 1.11.0 ", n = função (a, b) {retorna novo n.fn.init (a, b)}, o = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g, p = / ^ - ms - /, q = / - ([\ da-z]) / gi, r = função (a, b) { return b.toUpperCase ()}; n.fn = n.prototype = {jquery: m, construtor: n, seletor: "", comprimento: 0, toArray: function () {return d.call (this)}, get : function (a) {return null! = a? 0> a? this [a + this.length]: this [a]: d.call (this)}, pushStack: function (a) {var b = n. mesclar (this.constructor (), a); return b.prevObject = this, b.context = this.context, b}, each: function (a, b) {return n.each (this, a, b)}, map: function (a) {return this.pushStack (n .map (this, function (b, c) {return a.call (b, c, b)}))}, slice: function () {retorna this.pushStack (d.apply (this, argumentos))}, first: function () {return this.eq (0)}, last: function () {return this.eq (-1)}, eq: function (a) {var b = this.length, c = + a + ( 0> a? B: 0); return this.pushStack (c> = 0 && b> c? [This [c]]: [])}, end: function () {return this.prevObject || this.constructor (null )}, push: f, sort: c.sort, splice: c.splice}, n.extend = n.fn.extend = function () {var a, b, c, d, e, f, g = argumentos [0] || {}, h = 1, i = argumentos. Comprimento, j =! 1; para ("booleano" == tipo de g && (j = g, g = argumentos [h] || {}, h ++) , "objeto" == tipo de g || n.isFunção (g) || (g = {}), h === i && (g = isto, h -); i> h; h ++) if (null! = (e = argumentos [h])) para (d em e) a = g [d], c = e [d], g! == c && (j &&c && (n.isPlainObject (c) || ​​(b = n.isArray (c)))? (b? (b =! 1, f = a && n.isArray (a)? a: []): f = a && n. isPlainObject (a)? a: {}, g [d] = n.extend (j, f, c)): void 0! == c && (g [d] = c)); retorne g}, n.extend ({expando: "jQuery" + (m + Math.random ()). replace (/ \ D / g, ""), isReady:! 0, error: function (a) {throw new Error (a)}, noop: function () {}, isFunction: function (a) {return "function" === n.type (a)}, isArray: Array.isArray || function (a) {return "array" === .type (a)}, isWindow: function (a) {return null! = a && a == a.window}, isNumeric: function (a) {return a-parseFloat (a)> = 0}, isEmptyObject: function (a ) {var b; para (b em a) return! 1; return! 0}, isPlainObject: function (a) {var b; if (! a || "objeto"! == n.type (a) || a.nodeType || n.isWindow (a)) return! 1; tente {if (a.constructor &&! j.call (a, "constructor") &&! j.call (a.constructor.prototype,"isPrototypeOf")) return! 1} catch (c) {return! 1} if (l.ownLast) for (b in a) retorne j.call (a, b); for (b in a); return void 0 === b || j.call (a, b)}, digite: function (a) {return null == a? a + "": "objeto" == typeof a || "function" == typeof a? h [i.call (a)] || "objeto": tipo de a}, globalEval: function (b) {b && n.trim (b) && (a.execScript || função (b) {a.eval.call ( a, b)}) (b)}, camelCase: function (a) {return a.replace (p, "ms -"). replace (q, r)}, nodeName: function (a, b) {return a .nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()}, each: function (a, b, c) {var d, e = 0, f = comprimento, g = s (a); if (c) {if (g) {para (; f> e; e ++) if (d = b.apply (a [e], c), d ===! 1) break} else para (e em a) if (d = b.apply (a [e], c), d ===! 1) break} else if (g) {for (; f> e; e ++) if (d = b.call (a [ e], e, a [e]), d ===! 1) break} else para (e em a) if (d = b.call (a [e], e, a [e]), d = ==! 1) pausa; retorne a}, apare:k &&! k.call ("\ ufeff \ xa0")? function (a) {return null == a? "": k.call (a)}: function (a) {return null == a? "": (a + ""). replace (o, "")}, makeArray: function (a, b) {var c = b || []; return null! = a && (s (Object (a))? n.merge (c, "string" == tipo de a? [a]: a): f.call (c, a)), c}, emArray: function (a, b, c) {var d; if (b) { Se (g) retornar g.all (b, a, c); for (d = b.length, c = c? 0> c? Math.max (0, d + c): c: 0; d> c ; c ++) if (c em b &&b [c] === a) retornar c} return-1}, mesclar: function (a, b) {var c = + b.length, d = 0, e = a.length ; while (c> d) a [e ++] = b [d ++]; if (c! == c) while (void 0! == b [d]) a [e ++] = b [d ++]; retorne a. comprimento = e, a}, grep: function (a, b, c) {for (var d, e = [], f = 0, g = a.length, h =! c; g> f; f ++) d =! b (a [f], f), d! == h && e.push (a [f]); retorna e}, map: function (a, b, c) {var d, f = 0, g = a.length, h = s (a), i = []; se (h) para (; g> f; f ++) d = b (a [f], f, c), nulo! = d && i.push ( d);caso contrário, para (f em a) d = b (a [f], f, c), null! = d && i.push (d); return e.apply ([], i)}, guid: 1, proxy: function (a, b) {var c, e, f; return "string" == tipo de b && (f = a [b], b = a, a = f), n.isFunção (a)? (c = d. chamada (argumentos, 2), e = função () {retorna a.apply (b || isto, c.concat (d.call (argumentos)))}, e.guid = a.guid = a.guid || n.guid ++, e): void 0}, agora: function () {return + new Date}, suporte: l}), n.each ("Boolean Number String Função Array Data RegExp Object Error" .split ("") , function (a, b) {h ["[object" + b + "]"] = b.toLowerCase ()}); function s (a) {var b = a.length, c = n.type (a) ; return "function" === c || n.isWindow (a) ?! 1: 1 === a.nodeType && b?! 0: "array" === c || 0 === b || "número "== tipo de b && b> 0 && b-1 em a} var t = função (a) {var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p , q, r, s = "chiar" + - nova data, t = um documento, u = 0,v = 0, w = eb (), x = eb (), y = eb (), z = função (a, b) {retorna a === b && (j =! 0), 0}, A = " indefinido ", B = 1 << 31, C = {}. hasOwnProperty, D = [], E = D.pop, F = D. push, G = D. push, H = D. Slice, I = D. função indexOf || (a) {for (var b = 0, c = this.length; c> b; b ++) if (this [b] === a) retorno b; return-1}, J = "marcado | selecionado | assíncrono | foco automático | reprodução automática | controles | adiar | desativado | oculto | ismap | loop | múltiplo | aberto | somente leitura | necessário | escopo ", K =" [\\ x20 \\ t \\ r \\ n \\ f] ", L =" (?: \\\\. | [\\ w-] | [^ \\ x00 - \\ xa0]) + ", M = L. substituir (" w "," w # "), N =" \\ ["+ K +" * ("+ L +") "+ K +" * (?: ([* ^ $ |! ~]? =) "+ K +" * (?: ([ '\ "]) ((?: \\\\. | [^ \\\\]) *?) \\ 3 | (" + M + ") |) |)" + K + "* \\]", O = ":(" + L + ") (?: \\ (((['\"])) ((?: \\\\. | [^ \\\\]) *?) \\ 3 | ( (?: \\\\. | [^ \\\\ () [\\]] | "+ N. substituir (3,8) +") *) |. *) \\) |) ",P = novo RegExp ("^" + K + "+ | ((?: ^ | [^ \\\\]) (?: \\\\.) *)" + K + "+ $", "g") , Q = novo RegExp ("^" + K + "*," + K + "*"), R = novo RegExp ("^" + K + "* ([> + ~] |" + K + ")" + K + " * "), S = novo RegExp (" = "+ K +" * ([^ \\] '\ "] *?)" + K + "* \\]", "g"), T = novo RegExp (O ), U = new RegExp ("^" + M + "$"), V = {ID: new RegExp ("^ # (" + L + ")"), CLASS: new RegExp ("^ \\. (" + L + ")"), TAG: new RegExp ("^ (" + L.replace ("w", "w *") + ")"), ATTR: new RegExp ("^" + N), PSEUDO: novo RegExp ("^" + O), CHILD: new RegExp ("^ :( somente | primeiro | último | enésimo | enésimo -ésimo último) - (filho | do tipo) (?: \\ (" + K + "* ( par | ímpar | (([+ -] |) (\\ d *) n |) "+ K +" * (?: ([+ -] |) "+ K +" * (\\ d +) |)) " + K + "* \\) |)", "i"), bool: new RegExp ("^ (?:" + J + ") $", "i"), needsContext: new RegExp ("^" + K + "* [> + ~] |: (par | ímpar | eq | gt | lt | enésimo | primeiro | último) (?: \\ ("+ K +" * ((?: - \\ d)? \\ d *) "+ K +" * \\) | ) (? = [^ -] | $) "," i ")}, W = / ^ (?: input | select | textarea | button) $ / i, X = / ^ h \ d $ / i, Y = / ^ [^ {] + \ {\ s * \ [nativo \ w /, Z = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w-] +)) $ /, $ = / [+ ~] /, _ = / '| \\ / g, ab = novo RegExp ("\\\\ ([\\ da-f] {1,6}" + K + "? | (" + K + ") |.)", "Ig"), bb = função (a, b, c) {var d = "0x" + b-65536; retorno d! == d || c? b: 0> d? String.fromCharCode (d + 65536): String.fromCharCode (d >> 10 | 55296,1023 & d | 56320)}; tente {G.apply (D = H.call (t.childNodes) , t.childNodes), D [t.childNodes.length] .nodeType} catch (cb) {G = {apply: D.length? function (a, b) {F.apply (a, H.call (b) )}: function (a, b) {var c = a.length, d = 0; while (a [c ++] = b [d ++]); a.comprimento = c-1}}} função db (a, b, d, e) {var f, g, h, i, j, m, p, q, u, v; if ((b? b.ownerDocument | | b: t)! == l && k (b), b = b || l, d = d || [] ,! a || "string"! = tipo de a) retorna d; if (1! == ( i = b.nodeType) && 9! == i) return []; if (n &&! e) {if (f = Z.exec (a)) if (h = f [1]) {if (9 === i) {if (g = b.getElementById (h) ,! g ||! g.parentNode) return d; if (g.id === h) retorna d.push (g), d} else if (b .ownerDocument && (g = b.ownerDocument.getElementById (h)) && r (b, g) && g.id === h) retorna d.push (g), d} else {if (f [2]) retorna G. apply (d, b.getElementsByTagName (a)), d; if ((h = f [3]) && c.getElementsByClassName && b.getElementsByClassName) retorna G.apply (d, b.getElementsByClassName (h)), d} if (c .qsa && (! o ||! o.test (a))) {if (q = p = s, u = b, v = 9 === i && a, 1 === i && "objeto"! == b. nodeName.toLowerCase ()) {m = ob (a), (p = b.getAttribute ("id"))? q = p.replace (_, "\\ $ &"): b.setAttribute (" id ", q), q =" [id = '"+ q +"'] ", j = comprimento m; enquanto (j -) m [j] = q + pb ( m [j]); u = $. test (a) && mb (b.parentNode) || b, v = m.join (",")} se (v) tentar {retornar G.apply (d, u. querySelectorAll (v)), d} catch (w) {} finalmente {p || b.removeAttribute ("id")}}} retorne xb (a.replace (P, "$ 1"), b, d, e) } função eb () {var a = []; função b (c, e) {retorno a.push (c + "")> d.cacheLength && delete b [a.shift ()], b [c + ""] = e } retorna b} função fb (a) {retorna a [s] =! 0, a} função gb (a) {var b = l.createElement ("div"); tente {return !! a (b)} catch (c) {return! 1} finalmente {b.parentNode && b.parentNode.removeChild (b), b = null}} função hb (a, b) {var c = a.split ("|"), e = a. comprimento; while (e -) d.attrHandle [c [e]] = b} função ib (a, b) {var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType &&(~ b.sourceIndex || B) - (~ a.sourceIndex || B); if (d) return d; if (c) while (c = c.nextSibling) if (c === b) return-1 ; return a? 1: -1} function jb (a) {return function (b) {var c = b.nodeName.toLowerCase (); return "input" === c && b.type === a}} função kb (a) {função de retorno (b) {var c = b.nodeName.toLowerCase (); return ("entrada" === c || "botão" === c) && b.type === a}} função lb (a) {return fb (function (b) {return b = + b, fb (function (c, d) {var e, f = a ([], c.length, b), g = f.length ; while (g -) c [e = f [g]] && (c [e] =! (d [e] = c [e]))})})} função mb (a) {retorna um && tipo de a .getElementsByTagName! == A && a} c = db.support = {}, f = db.isXML = function (a) {var b = a && (a.ownerDocument || a) .documentElement; return b? "HTML"! = = b.nodeName:! 1}, k = db.setDocument = função (a) {var b, e = a? a.ownerDocument || a: t, g = e.defaultView; return e! == l && 9 == = e.nodeType && e.documentElement? (l = e, m = e.documentElement, n =! f (e), g && g! == g.top && (g.addEventListener? g.addEventListener ("descarregar", function () {k ()}, ! 1): g.attachEvent && g.attachEvent ("onunload", função () {k ()})), c.atributos = gb (função (a) {retornar a.className = "i",! A.getAttribute ( "className")}), c.getElementsByTagName = gb (function (a) {return a.appendChild (e.createComment (""))), a.getElementsByTagName ("*"). length}), c.getElementsByClassName = Y.test (e.getElementsByClassName) && gb (function (a) {return a.innerHTML = "<div class = 'a'> </div> <div class = 'a i'> </div>", a. firstChild.className = "i", 2 === a.getElementsByClassName ("i"). length}), c.getById = gb (function (a) {return m.appendChild (a) .id = s,! e .getElementsByName ||! e.getElementsByName (s) .length}), c.getById? (d.find.ID = função (a, b) {if (tipo de b.getElementById! == A && n) {var c = b.getElementById (a); return c && c.parentNode? [c]: []}}, d.filter.ID = função (a) {var b = a.replace (ab, bb); função de retorno (a) {return a.getAttribute ("id" ) === b}}) :( delete d.find.ID, d.filter.ID = função (a) {var b = a.replace (ab, bb); função de retorno (a) {var c = typeof a.getAttributeNode! == A && a.getAttributeNode ("id"); retorna c && c.value === b}}), d.find.TAG = c.getElementsByTagName? function (a, b) {tipo de retorno de b.getElementsByTagName! == A? B.getElementsByTagName (a): void 0}: function (a, b) {var c, d = [], e = 0, f = b.getElementsByTagName (a); if ("*" == = a) {while (c = f [e ++]) 1 === c.nodeType && d.push (c); return d} return f}, d.find.CLASS = c.getElementsByClassName && function (a, b) {return typeof b.getElementsByClassName! == A && n? b.getElementsByClassName (a): void 0}, p = [], o = [], (c.qsa = Y.test (e.querySelectorAll)) && (gb (function (a) {a.innerHTML = "<select t = ''> <opção selecionada = ''> </option> </select>", a.querySelectorAll ("[t ^ = '']"). length && o.push ("[* ^ $] = "+ K +" * (?: '' | \ "\") "), a.querySelectorAll (" [selected] "). Length || o.push (" \\ ["+ K +" * (?: valor | "+ J +") "), a.querySelectorAll (": marcado "). length || o.push (": marcado ")}), gb (função (a) {var b = e.createElement (" input "); b.setAttribute (" tipo "," oculto "), a.appendChild (b) .setAttribute (" nome "," D "), a.querySelectorAll (" [name = d] "). length && o. push ("nome" + K + "* [* ^ $ |! ~]? ="), a.querySelectorAll (": enabled"). length || o.push (": enabled", ": disabled"), a.querySelectorAll ("* ,: x"), o.push (",. *:")} )), (c.matchesSelector = Y.test (q = m.webkitMatchesSelector || m.mozMatchesSelector || m.oMatchesSelector || m.msMatchesSelector)) && gb (função (a) {c.disconnectedMatch = q.call (a , "div"), q.call (a, "[s! = '']: x"), p.push ("! =", O)}), o = o.length && new RegExp (o.join ( "|")), p = p.length && new RegExp (p.join ("|")), b = Y.test (m.compareDocumentPosition), r = b || Y.test (m.contains)? function ( a, b) {var c = 9 === a.nodeType? a.documentElement: a, d = b && b.parentNode; retorna a === d ||! (! d || 1! == d.nodeType | |! (c.contains? c.contains (d): a.compareDocumentPosition && 16 & a.compareDocumentPosition (d)))}: function (a, b) {if (b) enquanto (b = b.parentNode) if (b == = a) retorno!0; return! 1}, z = b? Function (a, b) {if (a === b) return j =! 0,0; var d =! A.compareDocumentPosition-! B.compareDocumentPosition; return d? d: (d = (a.ownerDocument || a) === (b.ownerDocument || b)? a.compareDocumentPosition (b): 1,1 & d ||! c.sortDetached && b.compareDocumentPosition (a) === d ? a === e || a.ownerDocument === t && r (t, a)? - 1: b === e | b.ownerDocument === t && r (t, b)? 1: i? I. chamada (i, a) -I.call (i, b): 0: 4 & d? -1: 1)}: function (a, b) {if (a === b) retorna j =! 0,0; var c, d = 0, f = a.parentNode, g = b.parentNode, h = [a], k = [b]; se (! f ||! g) retornar a === e? -1: b === e? 1: f? -1: g? 1: i? I.call (i, a) -I.call (i, b): 0; se (f === g) retornar ib ( a, b); c = a; while (c = c.parentNode) h.unshift (c); c = b; while (c = c.parentNode) k.unshift (c); while (h [d] = == k [d]) d ++; retorna d? ib (h [d], k [d]): h [d] === t? -1: k [d] === t? 1: 0} , e): l}, db.matches = função (a, b) {retorna db (a, nulo, nulo, b)}, db.matchesSelector = função (a, b) {if ((a.ownerDocument || a)! == l && k (a), b = b.replace (S, "= '$ 1']"),! (! c.matchesSelector ||! n || p && p.test (b) || o && o.test (b))) tente {var d = q.call (a, b); if (d || c.disconnectedMatch || a.document && 11! == a.document.nodeType) return d} catch (e) {} return db (b, l, null, [a]). length> 0}, db.contains = function (a, b) {return (a.ownerDocument || a)! == l && k (a), r (a, b)}, db.attr = função (a, b) {(a.ownerDocument || a)! == l && k (a); var e = d.attrHandle [b.toLowerCase ()], f = e && C.call (d.attrHandle , b.toLowerCase ())? e (a, b,! n): void 0; return void 0! == f? f: c.atributos ||! n? a.getAttribute (b) :( f = a .getAttributeNode (b)) && f.specified? f.value: null}, db.error = function (a) {throw new Error ("Erro de sintaxe, expressão não reconhecida:" + a)}, db.uniqueSort = function (a ) {var b, d = [], e = 0, f = 0; if (j =! c.detectDuplicates, i =! c.sortStable && a.slice (0), a.sort (z),j) {while (b = a [f ++]) b === a [f] && (e = d.push (f)); while (e -) a.splice (d [e], 1)} retornar i = nulo, a}, e = db.getText = função (a) {var b, c = "", d = 0, f = a.nodeType; if (f) {if (1 === f | | 9 === f || 11 === f) {if ("string" == tipo de a.textContent) retorna a.textContent; for (a = a.firstChild; a; a = a.nextSibling) c + = e (a)} else if (3 === f || 4 === f) retorna a.nodeValue} else while (b = a [d ++]) c + = e (b); return c}, d = db .selectors = {cacheLength: 50, createPseudo: fb, match: V, attrHandle: {}, encontre: {}, relativo: {">": {dir: "parentNode", primeiro:! 0}, "": { dir: "parentNode"}, "+": {dir: "previousSibling", primeiro:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: function (a) {retorne um [ 1] = a [1]. Substitua (ab, bb), a [3] = (a [4] || a [5] || ""). Substitua (ab, bb), "~ =" == = a [2] && (a [3] = "" + a [3] + ""), a.slice (0,4)},CRIANÇA: função (a) {retornar a [1] = a [1] .toLowerCase (), "enésimo" === a [1] .slice (0,3)? (A [3] || db.error (a [0]), a [4] = + (a [4]? a [5] + (a [6] || 1): 2 * ("par" === a [3] || " ímpar "=== a [3])), a [5] = + (a [7] + a [8] ||" ímpar "=== a [3])): a [3] && db.error (a [0]), a}, PSEUDO: function (a) {var b, c =! a [5] && a [2]; retorna V.CHILD.test (a [0])? null: (a [ 3] && void 0! == a [4]? A [2] = a [4]: ​​c &&teste de teste (c) && (b = ob (c,! 0)) && (b = c.indexOf (") ", c.length-b) -c.length) && (a [0] = a [0] .slice (0, b), a [2] = c.slice (0, b)), a.slice (0,3))}}, filtro: {TAG: function (a) {var b = a.replace (ab, bb) .toLowerCase (); return "*" === a? Function () {return! 0}: function (a) {return a.nodeName && a.nodeName.toLowerCase () === b}}, CLASSE: function (a) {var b = w [a + ""]; return b || (b = new RegExp ("(^ |" + K + ")" + a + "(" + K + "| $)")) && w (a, function (a) {return b.test ("string" == tipo de a.className && a.className || tipo de a.getAttribute! == A && a.getAttribute ("classe") || "")})} , ATTR: function (a, b, c) {return function (d) {var e = db.attr (d, a); return null == e? "! =" === b: b? (E + = "", "=" === b? e === c: "! =" === b? e! == c: "^ =" === b? c && 0 === e.indexOf (c ): "* =" === b? c && e.indexOf (c)> - 1: "$ =" === b? c && e.slice (-c.length) === c: "~ =" == = b? ("" + e + ""). índiceDe (c)> - 1: "| =" === b? e === c || e.slice (0, c.length + 1) == = c + "-" :! 1) :! 0}}, CRIANÇA: função (a, b, c, d, e) {var f = "enésimo"! == a.slice (0,3), g = "last"! == a.slice (-4), h = "do tipo" === b; return 1 === d && 0 === e? function (a) {return !! a.parentNode}: função (b, c, i) {var j, k, l, m, n, o, p = f!== g? "nextSibling": "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase (), t =! i &&! h; if (q) {if (f) {while (p) { l = b; while (l = l [p]) if (h? l.nodeName.toLowerCase () === r: 1 === l.nodeType) return! 1; o = p = "somente" == = a &&! o && "nextSibling"} retorna! 0} if (o = [g? q.firstChild: q.lastChild], g && t) {k = q [s] || (q [s] = {}), j = k [a] || [], n = j [0] === u && j [1], m = j [0] === u && j [2], l = n && q.childNodes [n]; while (l = ++ n && l && l [p] || (m = n = 0) || o.pop ()) if (1 === l.nodeType && ++ m && l === b) {k [a] = [u, n, m]; quebra}} senão se (t && (j = (b [s] || (b [s] = {})) [a]) && j [0] === u) m = j [1 ]; else while (l = ++ n && l && l [p] || (m = n = 0) || o.pop ()) if ((h? l.nodeName.toLowerCase () === r: 1 == = l.nodeType) && ++ m && (t && ((l [s] || (l [s] = {}))] [a] = [u, m]), l === b)) break; return m- = e,m === d || m% d === 0 && m / d> = 0}}}, PSEUDO: função (a, b) {var c, e = d.pseudos [a] || d.setFilters [a .toLowerCase ()] || db.error ("pseudo não suportado:" + a); return e [s]? e (b): e.length> 1? (c = [a, a, "", b] , d.setFilters.hasOwnProperty (a.toLowerCase ())? fb (function (a, c) {var d, f = e (a, b), g = comprimento f; enquanto (g -) d = I .call (a, f [g]), a [d] =! (c [d] = f [g])}): function (a) {return e (a, 0, c)}): e} }, pseudos: {not: fb (função (a) {var b = [], c = [], d = g (a.replace (P, "$ 1")); return d [s]? fb (function (a, b, c, e) {var f, g = d (a, nulo, e, []), h = a.length; while (h -) (f = g [h]) && (a [h] =! (b [h] = f))}): function (a, e, f) {return b [0] = a, d (b, nulo, f, c) ,! c.pop ( )}}), possui: fb (função (a) {função de retorno (b) {retorno db (a, b). comprimento> 0}}), contém: fb (função (a) {função de retorno (b) { return (b.textContent || b.innerText || e (b)). indexOf (a)> - 1}}), lang: fb (função (a) {return U.test (a || "") | db.error ("lang não suportado:" + a), a = a.replace (ab, bb) .toLowerCase (), function (b) {var c; faça if (c = n? b.lang: b.getAttribute (" xml: lang ") || b.getAttribute (" lang ")) retorna c = c.toLowerCase (), c === a || 0 === c.indexOf (a +" - "); while ((b = b.parentNode) && 1 === b.nodeType); return! 1}}), target: function (b) {var c = a.location && a.location.hash; return c && c.slice (1) === b .id}, raiz: função (a) {retorna a === m}, foco: função (a) {retorna a === l.activeElement && (! l.hasFocus || l.hasFocus ()) && !! (a.type || a.href || ~ a.tabIndex)}, ativado: function (a) {return a.disabled ===! 1}, desativado: function (a) {return a.disabled === ! 0}, verificado: function (a) {var b = a.nodeName.toLowerCase (); return "input" === b && !! a.checked || "option" === b && !! a.selected} , selecionado: function (a) {return a.parentNode && a.parentNode.selectedIndex, a.selected ===! 0}, vazio: function (a) {for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType <6) return! 1; return! 0 }, pai: função (a) {retorno! d.pseudos.empty (a)}, cabeçalho: função (a) {retorno X.test (a.nodeName)}, entrada: função (a) {retorno W.test (a.nodeName)}, botão: function (a) {var b = a.nodeName.toLowerCase (); retorna "input" === b && "button" === a.type || "button" === b}, texto: function (a) {var b; retorna "input" === a.nodeName.toLowerCase () && "text" === a.type && (null == (b = a.getAttribute ("type ")) ||" text "=== b.toLowerCase ())}, primeiro: lb (função () {return [0]}), último: lb (função (a, b) {return [b-1 ]}), eq: lb (função (a, b, c) {return [0> c? c + b: c]}), par: lb (função (a, b) {for (var c = 0; b> c; c + = 2) a.push (c); return a}), ímpar: lb (função (a, b) {for (var c = 1; b> c; c + = 2) a.push ( c); retornar a}), lt:lb (função (a, b, c) {para (var d = 0> c? c + b: c; - d> = 0;) a.push (d); retorna a}), gt: lb ( função (a, b, c) {para (var d = 0> c? c + b: c; ++ d <b;) a.push (d); retorna a})}}, d.pseudos.nth = d.pseudos.eq; para (b em {radio:! 0, caixa de seleção:! 0, arquivo:! 0, senha:! 0, imagem:! 0}) d.pseudos [b] = jb (b); para (b em {enviar:! 0, redefinir:! 0}) d.pseudos [b] = kb (b); função nb () {} nb.prototype = d.filters = d.pseudos, d.setFilters = new nb; function ob (a, b) {var c, e, f, g, h, i, j, k = x [a + ""]; se (k) retornar b? 0: k.slice (0) ; h = a, i = [], j = d.preFilter; while (h) {(! c || (e = Q.exec (h))) && (e && (h = h.slice (e [0 ] .length) || h), i.push (f = [])), c =! 1, (e = R.exec (h)) && (c = e.shift (), f.push ({ valor: c, tipo: e [0] .replace (P, "")}), h = h.slice (c.length)); para (g em filtro d)! (e = V [g]. exec (h)) || j [g] &&! (e = j [g] (e)) || (c = e.shift (), f.push ({valor: c, tipo: g, corresponde a: e}), h = h.slice (c.length)); se (! c) break} retornar b? h.length: h? db.erro (a): x (a, i) .slice (0)} função pb (a) {for (var b = 0, c = a.length, d = ""; c> b; b ++) d + = a [b] .value; return d} função qb (a, b, c) {var d = b.dir, e = c && "parentNode" === d, f = v ++; return b.first? function (b, c, f) {while (b = b [d]) if (1 === b.nodeType || e) retorna a (b, c, f)}: função (b, c, g) {var h, i, j = [u, f]; if (g) {while (b = b [d]) if ((1 === b.nodeType || e) && a (b, c, g)) retornam! 0 } else while (b = b [d]) if (1 === b.nodeType || e) {if (i = b [s] || (b [s] = {}), (h = i [ d)) && h [0] === u && h [1] === f) retorna j [2] = h [2]; se (i [d] = j, j [2] = a (b, c, g)) return! 0}}} função rb (a) {return a.length> 1? function (b, c, d) {var e = a.length; while (e -) if (! a [e ] (b, c, d)) return! 1; return! 0}: a [0]} função sb (a, b, c, d, e) {para (var f, g = [], h = 0 , i = a.length, j = nulo! = b; i> h; h ++) (f = a [h]) && (! c || c (f, d, e)) && (g.push (f ), j && b.push (h)); return g} função tb (a, b, c, d, e, f) {return d &&! d [s] && (d = tb (d)), e &&! e [s] && (e = tb (e, f)), fb (função (f, g, h, i) {var j, k, l, m = [], n = [], o = g.length, p = f || wb (b || "*", h.nodeType? [h]: h, []), q =! a ||! f &&b ? p: sb (p, m, a, h, i), r = c? e || (f? a: o || d)? []: g: q; if (c && c (q, r, h , i), d) {j = sb (r, n), d (j, [], h, i), k = j.length; while (k -) (l = j [k]) && ( r [n [k]] =! (q [n [k]] = l))} if (f) {if (e || a) {if (e) {j = [], k = comprimento de r. ; while (k -) (l = r [k]) && j.push (q [k] = l); e (nulo, r = [], j, i)} k = r.length; while (k -) (l = r [k]) && (j = e? I.call (f, l): m [k])> - 1 && (f [j] =! (g [j] = l)) }} else r = sb (r === g? r.splice (o, r.length): r), e? e (nulo, g, r, i): G.apply (g, r)}) } função ub (a) {para (var b, c, e, f = a.length, g = d.relativo [a [0] .tipo], i = g || d.relativo [""], j = g? 1: 0, k = qb (função (a) {retorna a === b}, i,! 0), l = qb (função (a) {retorna I.call (b, a)> - 1}, i,! 0), m = [função (a, c, d) {return! G && (d || c! == h) || ((b = c) .nodeType? K (a, c , d): l (a, c,d))}]; f> j; j ++) if (c = d.relativo [a [j] .type]) m = [qb (rb (m), c)]; else {if (c = d. filter [a [j] .type] .apply (null, a [j] .matches), c [s]) {for (e = ++ j; f> e; e ++) if (d.relative [a [ e] .type]) break; return tb (j> 1 && rb (m), j> 1 && pb (a.slice (0, j-1) .concat ({value: "" === a [j-2]). digite? "*": ""})). replace (P, "$ 1"), c, e> j && ub (a.slice (j, e)), f> e && ub (a = a.slice (e)) , f> e && pb (a))} m.push (c)} retorna rb (m)} função vb (a, b) {var c = comprimento b> 0, e = a.length> 0, f = função (f, g, i, j, k) {var m, n, o, p = 0, q = "0", r = f && [], s = [], t = h, v = f || e & d .find.TAG ("*", k), w = u + = null == t? 1: Math.random () || .1, x = v.length; for (k && (h = g! == l && g ); q! == x && null! = (m = v [q]); q ++) {if (e && m) {n = 0; while (o = a [n ++]) if (o (m, g, i)) {j.push (m); break} k && (u = w)} c ​​&& ((m =! o && m) && p -, f && r.push (m))} if (p + = q, c && q! == p) {n = 0; while (o = b [n ++]) o (r, s, g, i); se (f) {se (p> 0) enquanto (q -) r [q] || s [q] || (s [q] = chamada E. (j)); s = sb (s)} G .apply (j, s), k &&! f && s.length> 0 && p + b.length> 1 && db.uniqueSort (j)} retornar k && (u = w, h = t), r}; retornar c? fb (f): f} g = db.compile = função (a, b) {var c, d = [], e = [], f = y [a + ""]; se (! f) {b || (b = ob (a)), c = b.length; while (c -) f = ub (b [c]), f [s]? d.push (f): e.push (f); f = y ( a, vb (e, d))} retorna f}; função wb (a, b, c) {para (var d = 0, e = b.length; e> d; d ++) db (a, b [d ], c); return c} função xb (a, b, e, f) {var h, i, j, k, l, m = ob (a); if (! f && 1 === m.length) { if (i = m [0] = m [0]. fatia (0), comprimento i> 2 && "ID" === (j = i [0]). tipo && c.getById && 9 === b.nodeType && n && d.relative [i [1] .type]) {if (b = (d.find.ID (j.parece [0]. substitua (ab, bb), b) || []) [0] ,! b) return e; a = uma fatia (i.shift (). value.length)} h = V.needsContext.test (a)? 0: i.length; while (h -) {if (j = i [h], d.relativo [k = j. tipo]) break; if ((l = d.find [k]) && (f = l (j.matches [0]. substitua (ab, bb), $. test (i [0] .type) && mb ( b.parentNode) || b))) {if (i.splice (h, 1), a = f.length && pb (i) ,! a) return G.apply (e, f), e; break}}} return g (a, m) (f, b,! n, e, $. test (a) && mb (b.parentNode) || b), e} retorna c.sortStable = s.split (""). (z) .join ("") === s, c.detectDuplicates = !! j, k (), c.sortDetached = gb (função (a) {return 1 & a.compareDocumentPosition (l.createElement ("div")) )}), gb (função (a) {retornar a.innerHTML = "<a href='#'> </a>", "#" === a.firstChild.getAttribute ("href")}) | | hb ("tipo | href | altura | largura", função (a, b, c) {retorno c? void 0: a.getAttribute (b, "tipo" === b.toLowerCase ()? 1: 2) }), c.atributos e&gb (function (a) {return a.innerHTML = "<input />", a.firstChild.setAttribute ("value", "")) "" === a.firstChild.getAttribute ("value")}) || hb ("valor", função (a, b, c) {retornar c || "entrada"! == a.nodeName.toLowerCase ()? void 0: a.defaultValue}), gb (função (a) {return null == a.getAttribute ("disabled")}) || hb (J, função (a, b, c) {var d; return c? void 0: a [b] ===! 0? b .toLowerCase () :( d = a.getAttributeNode (b)) && d.specified? d.value: null}), db} (a); n.find = t, n.expr = t.seletores, n.expr [":"] = n.expr.pseudos, n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains; var u = n.expr .match.needsContext, v = / ^ <(\ w +) \ s * \ /?> (?: <\ / \ 1> |) $ /, w = / ^. [^: # \ [\.,] * $ /; função x (a, b, c) {if (n.isFunção (b)) retorna n.grep (a, função (a, d) {retorna !! b.call (a, d, a) ! == c}); if (b.nodeType) return n.grep (a, function (a) {return a === b! == c}); if ("string" == typeof b) {if (w.test (b)) retorna n. filter (b, a, c); b = n.filter (b, a)} return n.grep (a, function (a) {return n.inArray (a, b)> = 0! == c}) } n.filter = função (a, b, c) {var d = b [0]; retorna c && (a = ": not (" + a + ")"), 1 === b.length && 1 === d .nodeType? n.find.matchesSelector (d, a)? [d]: []: n.find.matches (a, n.grep (b, função (a) {return 1 === a.nodeType}) )}, n.fn.extend ({find: function (a) {var b, c = [], d = this, e = d.length; if ("string"! = typeof a) retorna this.pushStack ( n (a) .filter (função () {for (b = 0; e> b; b ++) if (n.contains (d [b], this)) return! 0})); for (b = 0; e> b; b ++) n.find (a, d [b], c); return c = this.pushStack (e> 1? n.unique (c): c), c.selector = this.selector? this .selector + "" + a: a, c}, filter: function (a) {retorna this.pushStack (x (isto, a || [] ,! 1))}, e não: function (a) {retorna isso.pushStack (x (isto, a || [] ,! 0))}, é: function (a) {return !! x (this, "string" == typeof a && u.test (a)? n (a): a || [] ,! 1) .length}}); var y, z = a.document, A = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] *)) $ /, B = n.fn.init = função (a, b) {var c, d; if (! a) retorna isso; if ("string" == typeof a) {if (c = "<" === a.charAt (0) && ">" === a.charAt (a.length-1) && a.length> = 3? [null, a, null] : A.exec (a) ,! c ||! C [1] && b) return! B || b.jquery? (B || y) .find (a): este.construtor (b) .find (a ); if (c [1]) {if (b = b instância de n? b [0]: b, n.merge (esta, n.parseHTML (c [1], b && b.nodeType? b.ownerDocument || b : z,! 0)), v.test (c [1]) && n.isPlainObject (b)) para (c em b) n.isFunction (this [c])? this [c] (b [c]) : this.attr (c, b [c]); retorne} se (d = z.getElementById (c [2]), d && d.parentNode) {if (d.id! == c [2]) retorne y .find (a); this.length = 1, este [0] = d} retorna isso.context = z, this.selector = a, this} retorna a.nodeType? (this.context = this [0] = a, this.length = 1, this): n.isFunction (a)? "undefined"! = tipo de y.ready? y.ready (a): a (n) :( void 0! == a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray (a, this))}; B.prototype = n.fn, y = n (z); var C = / ^ (?: pais | prev (?: Até | Todos)) /, D = {filhos:! 0, conteúdo :! 0, próximo:! 0, prev:! 0}; n.extend ({dir: função (a, b, c) {var d = [], e = a [b]; while (e && 9! == e.nodeType && (void 0 === c || 1! == e.nodeType ||! n (e) .is (c))) 1 === e.nodeType && d.push (e), e = e [ b); return d}, irmão: function (a, b) {for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a! == b && c.push (a); return c}}), n.fn.extend ({has: function (a) {var b, c = n (a, this), d = c.length; retorna this.filter (function () {for (b = 0; d> b; b ++) if (n.contains (this, c [b])) return! 0})}, mais próximo: function (a, b) {for (var c, d = 0, e = this .comprimento,f = [], g = u.teste (a) || "string"! = tipo de a? n (a, b || este.context): 0; e> d; d ++) para (c = this [d ]; c && c! == b; c = c.parentNode) if (c.nodeType <11 && (g? g.index (c)> - 1: 1 === c.nodeType && n.find.matchesSelector (c, a) )) {f.push (c); break} retorna this.pushStack (f.length> 1? n.unique (f): f)}, índice: function (a) {retorna uma? "string" == typeof a? n.inArray (this [0], n (a)): n.inArray (a.jquery? a [0]: a, this): this [0] && this [0] .parentNode? this.first ( ) .prevAll (). length: -1}, add: function (a, b) {retorna this.pushStack (n.unique (n.merge (this.get (), n (a, b))))} , addBack: function (a) {return this.add (null == a? this.prevObject: this.prevObject.filter (a))}}); function E (a, b) {do a = a [b] ; while (a && 1! == a.nodeType); return a} n.each ({parent: function (a) {var b = a.parentNode; return b && 11! == b.nodeType? b: null}, os pais: função (a) {return n.dir (a, "parentNode ")}, parentsUntil: function (a, b, c) {return n.dir (a," parentNode ", c)}, next: function (a) {return E (a," nextSibling ")}, prev : function (a) {return E (a, "previousSibling")}, nextAll: function (a) {return n.dir (a, "nextSibling")}, prevAll: function (a) {return n.dir (a , "previousSibling")}, nextUntil: function (a, b, c) {return n.dir (a, "nextSibling", c)}, prevUntil: function (a, b, c) {return n.dir (a , "previousSibling", c)}, irmãos: function (a) {return n.sibling ((a.parentNode || {}). firstChild, a)}, filhos: function (a) {return n.sibling (a .firstChild)}, conteúdo: function (a) {return n.nodeName (a, "iframe")? a.contentDocument || a.contentWindow.document: n.merge ([], a.childNodes)}}, function (a, b) {n.fn [a] = função (c, d) {var e = n.map (isto, b, c); retorne "Até"! == a.slice (-5) && ( d = c), d && "string "== tipo de d && (e = n.filtro (d, e)), este.length> 1 && (D [a] || (e = n. exclusivo (e)), C.test (a) && ( e = e.reverse ())), this.pushStack (e)}}); var F = / \ S + / g, G = {}; função H (a) {var b = G [a] = {} ; return n.each (a.match (F) || [], função (a, c) {b [c] =! 0}), b} n.Callbacks = function (a) {a = "string" == tipo de a? G [a] || H (a): n.extend ({}, a); var b, c, d, e, f, g, h = [], i =! a.once && [], j = função (l) {para (c = memória.m & l, d =! 0, f = g || 0, g = 0, e = h.length, b =! 0; h && e> f; f ++) ) if (h [f] .apply (l [0], l [1]) ===! 1 && a.stopOnFalse) {c =! 1; break} b =! 1, h && (i? i.length && j (i .shift ()): c? h = []: k.disable ())}, k = {add: function () {if (h) {var d = h.length;! function f (b) {n .each (b, function (b, c) {var d = n.type (c); "function" === d? a.unique && k.has (c) || ​​h.push (c): c &&c.length && "string"! == d && f (c)})} (argumentos), b? e = h.length:c && (g = d, j (c))} retorna isso}, remove: function () {retorna h && n.each (argumentos, função (a, c) {var d; while ((d = n.inArray (c, h, d))> - 1) h.splice (d, 1), b && (e> = d && e -, f> = d && f -)}), isto}, possui: function (a) {return a? n.inArray (a, h)> - 1:! (! h ||! h.length)}, vazio: function () {retorna h = [], e = 0, isto}, desativa: function () { return h = i = c = void 0, this}, desativado: function () {return! h}, lock: function () {return i = void 0, c || k.disable (), this}, travado: function () {return! i}, fireWith: function (a, c) {return! h || d &&! i || (c = c || [], c = [a, c.slice? c.slice ( ): c], b? i.push (c): j (c)), isto}, fire: function () {retorna k.fireCom (isso, argumentos), isso}, disparou: function () {return! ! d}}; return k}, n.extend ({adiado: função (a) {var b = [["resolve", "done", n "). n.Callbacks (" once memory ")," resolved "], [ "rejeitar", "falhar", n.Callbacks ("uma vez memória"), "rejeitado"], ["notificar", "progresso", n.Callbacks ("memória")]], c = "pendente", d = {state: function () {return c }, sempre: function () {retorna e.done (argumentos) .fail (argumentos), isso}, então: function () {var a = argumentos; retorna n.Deferido (função (c) {n.each (b , função (b, f) {var g = n.isFunção (a [b]) && a [b]; e [f [1]] (função () {var a = g && g.apply (isto, argumentos); a && n .isFunction (a.promise)? a.promise (). done (c.resolve) .fail (c.reject) .progress (c.notify): c [f [0] + "With"] (this == = d? c.promise (): isto, g? [a]: argumentos)})}), a = nulo}). promessa ()}, promessa: função (a) {retorno nulo! = a? n. estender (a, d): d}}, e = {}; retornar d.pipe = d.then, n.each (b, função (a, f) {var g = f [2], h = f [ 3]; d [f [1]] = g.add, h && g.add (função () {c = h}, b [1 ^ a] [2] .disable, b [2] [2] .lock) , e [f [0]] = função () {retorna e [f [0] + "Com "] (isto === e? D: isto, argumentos), isto}, e [f [0] +" Com "] = g.fireWith}), d.promise (e), um && a.call (e , e), e}, quando: função (a) {var b = 0, c = d.call (argumentos), e = c.length, f = 1! == e || a && n.isFunction (a.promise )? e: 0, g = 1 === f? a: n.Deferido (), h = função (a, b, c) {função de retorno (e) {b [a] = this, c [a] = argumentos.length> 1? d.call (argumentos): e, c === i? g.notifyWith (b, c): - f || g.resolveWith (b, c)}}, i, j , k; if (e> 1) para (i = nova matriz (e), j = nova matriz (e), k = nova matriz (e); e> b; b ++) c [b] && n.isFunction (c [b] .promise)? c [b] .promise (). done (h (b, k, c)). fail (g.reject) .progress (h (b, j, i)): - f ; return f || g.resolveWith (k, c), g.promise ()}}); var I; n.fn.ready = function (a) {return n.ready.promise (). done (a) , this}, n.extend ({isReady:! 1, readyWait: 1, holdReady: function (a) {a? n.readyWait ++: n.ready (! 0)}, ready: function (a) {if (a ===! 0?! - n.readyWait:! N.isReady) {if (! Z.body) retorna setTimeout (n.pronto); n.isReady =! 0, a! ==! 0 && - n.readyWait> 0 || (I.resolveWith (z, [n]), n.fn.trigger && n (z) .trigger ("pronto ") .off (" ready "))}}}); função J () {z.addEventListener? (z.removeEventListener (" DOMContentLoaded ", K,! 1), a.removeEventListener (" load ", K ,! 1)) :( z.detachEvent ("onreadystatechange", K), a.detachEvent ("onload", K))} função K () {(z.addEventListener || "load" === event.type || "complete" === z.readyState) && (J (), n.ready ())} n.ready.promise = function (b) {if (! I) if (I = n.Deferred (), " complete "=== z.readyState) setTimeout (n.ready); caso contrário, se (z.addEventListener) z.addEventListener (" DOMContentLoaded ", K,! 1), a.addEventListener (" load ", K,! 1) ; else {z.attachEvent ("onreadystatechange", K), a.attachEvent ("onload", K); var c =! 1; tente {c = null == a.frameElement && z.documentElement} catch (d) {} ​​c && c.doScroll &&! function e () {if (! n.isReady) {tente {c.doScroll ("left")} catch (a) {retorne setTimeout (e, 50) } J (), n.ready ()}} ()} retorna I. promessa (b)}; var L = "indefinido", M; para (M em n (l)) quebra; l.ownLast = "0 "! == M, l.inlineBlockNeedsLayout =! 1, n (function () {var a, b, c = z.getElementsByTagName (" body ") [0]; c && (a = z.createElement (" div ") , a.style.cssText = "borda: 0; largura: 0; altura: 0; posição: absoluta; parte superior: 0; esquerda: -9999px; margem superior: 1px", b = z.createElement ("div") , c.appendChild (a) .appendChild (b), tipo de b.style.zoom! == L&& (b.style.cssText = "borda: 0; margem: 0; largura: 1px; preenchimento: 1px; exibição: em linha ; zoom: 1 ", (l.inlineBlockNeedsLayout = 3 === b.offsetWidth) && (c.style.zoom = 1)), c.removeChild (a), a = b = null)}), function () {var a = z.createElement ("div"); if (null == l.deleteExpando) {l.deleteExpando =! 0; tente {excluir a.test} catch (b) {l.deleteExpando =! 1}} a = null} () , n.acceptData = função (a) {var b = n.noData [(a.nodeName + "") .toLowerCase ()], c = + a.nodeType || 1; retorne 1! == c && 9! == c ?! 1:! B || b! ==! 0 && a.getAttribute ("classid") === b}; var N = / ^ (?: \ {[\ W \ W] * \} | \ [[ \ w \ W] * \]) $ /, O = / ([AZ]) / g; função P (a, b, c) {if (void 0 === c && 1 === a.nodeType) {var d = "data -" + b.replace (O, "- $ 1"). toLowerCase (); if (c = a.getAttribute (d), "string" == tipo de c) {try {c = "true" === c?! 0: "false" === c?! 1: "null" === c? null: + c + "" === c? + c: N.test (c)? n. parseJSON (c): c} catch (e) {} n.dados (a, b, c)} else c = void 0} retorna c} função Q (a) {var b; for (b em a) if ( ("dados"! == b ||! n.isEmptyObject (a [b])) && "toJSON"! == b) return! 1; return!0} função R (a, b, d, e) {if (n.acceptData (a)) {var f, g, h = n.expando, i = a.nodeType, j = i? N.cache: a , k = i? a [h]: a [h] && h; if (k && j [k] && (e || j [k] .dados) || void 0! == d || "string"! = typeof b) retornar k || (k = i? a [h] = c.pop () || n.guid ++: h), j [k] || (j [k] = i? {}: {toJSON: n.noop}), ("objeto" == tipo de b || "função" == tipo de b) && (e? j [k] = n.extend (j [k], b): j [k]. data = n.extend (j [k] .data, b)), g = j [k], e || (g.data || (g.data = {}), g = g.data), nulo 0! == d && (g [n.camelCase (b)] = d), "string" == tipo de b? (F = g [b], nulo == f && (f = g [n.camelCase (b)) ])): f = g, fobjeto "== tipo de b ||" função "== tipo de b) && (e? j [k] = n.extend (j [k], b): j [k] .data = n.extend (j [ k] .dados, b)), g = j [k], e || (g.data || (g.data = {}), g = g.data), nulo 0! == d && (g [ n.camelCase (b)] = d), "string" == tipo de b? (f = g [b], null == f && (f = g [n.camelCase (b)])): f = g, fobjeto "== tipo de b ||" função "== tipo de b) && (e? j [k] = n.extend (j [k], b): j [k] .data = n.extend (j [ k] .dados, b)), g = j [k], e || (g.data || (g.data = {}), g = g.data), nulo 0! == d && (g [ n.camelCase (b)] = d), "string" == tipo de b? (f = g [b], null == f && (f = g [n.camelCase (b)])): f = g, f
}} função S (a, b, c) {if (n.acceptData (a)) {var d, e, f = a.nodeType, g = f? n.cache: a, h = f? a [n .expando]: n.expando; if (g [h]) {if (b && (d = c? g [h]: g [h]. dados)) {n.isArray (b)? b = b.concat (n.map (b, n.camelCase)): b em d? b = [b] :( b = n.camelCase (b), b = b em d? [b]: b.split ("") ), e = b.length; while (e -) delete d [b [e]]; if (c?! Q (d) :! n.isEmptyObject (d)) retorne} (c || (delete g [h] .dados, Q (g [h]))) && (f? n.cleanData ([a] ,! 0): l.deleteExpando || g! = g.window? delete g [h]: g [h] = null)}}} n.extend ({cache: {}, noData: {"applet":! 0, "embed":! 0, "object": "clsid: D27CDB6E-AE6D-11cf-96B8 -444553540000 "}, hasData: function (a) {return a = a.nodeType? N.cache [a [n.expando]]: a [n.expando], !! a &&! Q (a)}, dados: função (a, b, c) {retornar R (a, b, c)}, removeData: função (a, b) {retornar S (a, b)}, _ dados: função (a, b, c) {retornar R (a, b, c,! 0)}, _ removeData: function (a, b) {retorna S (a, b ,!0)}}), n.fn.extend ({data: function (a, b) {var c, d, e, f = this [0], g = f && f.atributes; if (void 0 === a ) {if (this.length && (e = n.data (f), 1 === f.nodeType &&! n._data (f, "parsedAttrs")))) {c = g.length; while (c--) d = g [c] .name, 0 === d.indexOf ("data -") && (d = n.camelCase (d.slice (5)), P (f, d, e [d])) ; n._data (f, "parsedAttrs",! 0)} retornar e} retornar "objeto" == tipo de a? this.each (function () {n.data (this, a)}): argument.length> 1? This.each (function () {n.data (this, a, b)}): f? P (f, a, n.data (f, a)): void 0}, removeData: function (a ) {return this.each (function () {n.removeData (this, a)})}}), n.extend ({fila: function (a, b, c) {var d; retorna a? (b = (b || "fx") + "fila", d = n._dados (a, b), c && (! d || n.isArray (c)? d = n._dados (a, b, n.makeArray (c)): d.push (c)), d || []): void 0}, desenfileirar: função (a, b) {b = b || "fx"; var c = n.queue (a , b), d = c.length, e = c.shift (), f = n._queueHooks (a, b), g = function () {n.dequeue (a, b)}; "inprogress" === e && (e = c.shift (), d -), e && ("fx" === b && c.unshift ("inprogress"), exclua f.stop, e.call (a, g, f)) ,! d && f && f.empty.fire () }, _ queueHooks: function (a, b) {var c = b + "queueHooks"; retorna n._dados (a, c) || ​​n._dados (a, c, {vazio: n.Callbacks ("once memory") .add (function () {n._removeData (a, b + "fila"), n._removeData (a, c)})})}}), n.fn.extend ({fila: function (a, b) {var c = 2; return "string"! = typeof a && (b = a, a = "fx", c -), argumentos.length <c? n.queue (this [0], a): void 0 === b? this: this.each (function () {var c = n.queue (this, a, b); n._queueHooks (this, a), "fx" === a && "inprogress"! = = c [0] && n.dequeue (this, a)})}, dequeue: function (a) {retorna this.each (function () {n.dequeue (this, a)})}, clearQueue: function (a) {return this.queue (a || "fx", [])}, promessa: function (a, b) {var c, d = 1, e = n.Deferido (), f = isto, g = este.length, h = função () {- d || e.resolveWith (f, [f])}; "string"! = tipo de a && (b = a, a = void 0), a = a || "fx"; while (g -) c = n._dados (f [g], a + "queueHooks"), c && c.empty && (d ++, c.empty .add (h)); return h (), e.promise (b)}}); var T = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [ + -]? \ d + |) /. fonte, U = ["Superior", "Direita", "Inferior", "Esquerda"], V = função (a, b) {retorna a = b || a, " nenhum "=== n.css (a," exibição ") ||! n.contains (a.ownerDocument, a)}, W = n.access = function (a, b, c, d, e, f, g) {var h = 0, i = a.length, j = nulo == c; if ("objeto" === n.tipo (c)) {e =! 0; para (h em c) n. acesso (a, b, h, c [h] ,! 0, f, g)} else if (void 0! == d && (e =! 0, n.isFunção (d) || (g =! 0)) , j && (g? (chamada b (a, d),b = nulo) :( j = b, b = função (a, b, c) {retorna j.call (n (a), c)})), b)) para (; i> h; h ++) b (a [h], c, g? d: d.call (a [h], h, b (a [h], c))); retorne e? a: j? b.call (a): i ? b (a [0], c): f}, X = / ^ (?: caixa de seleção | radio) $ / i;! function () {var a = z.createDocumentFragment (), b = z.createElement (" div "), c = z.createElement (" entrada "); if (b.setAttribute (" className "," t "), b.innerHTML =" <link/><table> </table> <a href = '/ a'> a </a> ", l.leadingWhitespace = 3 === b.firstChild.nodeType, l.tbody =! b.getElementsByTagName (" tbody "). comprimento, l.htmlSerialize = !! b. getElementsByTagName ("link"). length, l.html5Clone = "<: nav> </: nav>"! == z.createElement ("nav"). cloneNode (! 0) .outerHTML, c.type = "caixa de seleção ", c.checked =! 0, a.appendChild (c), l.appendChecked = c.checked, b.innerHTML =" <textarea> x </textarea>",l.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue,a.appendChild(b),b.innerHTML="<inputHTML="<inputHTML="<input type = 'radio' marcada = 'marcada' name = ' t '/> ", l.checkClone = b.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, l.noCloneEvent =! 0, b.attachEvent && (b.attachEvent (" onclick ", function ()) {l.noCloneEvent =! 1}), b.cloneNode (! 0) .click ()), null == l.deleteExpando) {l.deleteExpando =! 0; tente {excluir b.test} captura (d) { l.deleteExpando =! 1}} a = b = c = nulo} (), função () {var b, c, d = z.createElement ("div"); para (b em {submit:! 0, altere :! 0, focusin:! 0}) c ​​= "on" + b, (l [b + "Bubbles"] = c em a) || (d.setAttribute (c, "t"), l [b + "Bubbles "] = atributos d [c] .expando === 1); d = nulo} (); var Y = / ^ (?: entrada | selecione | área de texto) $ / i, Z = / ^ tecla /, $ = / ^ (?: mouse | menu de contexto) | clique em /, _ = / ^ (?: focusinfocus | focusoutblur) $ /,ab = / ^ ([^.] *) (?: \. (. +) |) $ /; função bb () {return! 0} função cb () {return! 1} função db () {try { return z.activeElement} catch (a) {}} n.event = {global: {}, add: function (a, b, c, d, e) {var f, g, h, i, j, k, l, m, o, p, q, r = n._dados (a); se (r) {c.handler && (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = n.guid ++), (g = r.events) || (g = r.events = {}), (k = r.handle) || (k = r.handle = function (a) {return typeof n === L || a && n.event.triggered === a.type? void 0: n.event.dispatch.apply (k.elem, argumentos)}, k.elem = a), b = (b || ""). match (F) || [""], h = b.length; enquanto (h -) f = ab.exec (b [h]) || [], o = q = f [1], p = (f [2] || ""). split ("."). sort (), o && (j = n.event.special [o] || {}, o = ( e? j.delegateType: j.bindType) || o, j = n.event.special [o] || {}, l = n.extend ({type: o, origType: q, dados: d, manipulador: c, guid: c.guid, seletor: e, needsContext: e && n.expr.match.needsContext.test (e), espaço para nome: p.junção (".")}, i), (m = g [o]) || (m = g [o] = [], m.delegateCount = 0, j.setup && j.setup.call (a, d, p, k)! ==! 1 || (a.addEventListener? a.addEventListener (o, k,! 1): a.attachEvent && a.attachEvent ("on" + o, k))), j.add && (j .add.call (a, l), l.handler.guid || (l.handler.guid = c.guid)), e? m.splice (m.delegateCount ++, 0, l): m.push (l ), n.event.global [o] =! 0); a = null}}, remove: function (a, b, c, d, e) {var f, g, h, i, j, k, l , m, o, p, q, r = n.hasDados (a) && n._data (a); if (r && (k = r.eventos)) {b = (b || ""). match (F) || [""], j = b.length; while (j -) if (h = ab.exec (b [j]) || [], o = q = h [1], p = (h [2] || ""). Split ("."). Sort (), o) {l = n.event.special [o] || {}, o = (d? L.delegateType: l.bindType ) || o, m = k [o] || [], h = h [2] && new RegExp ("(^ | \\.)" + p.join ("\\. (?:. * \\ . |) ") +" (\\. | $) "), i = f = m.length; enquanto (f -) g = m [f] ,! e && q! == g.origType || c && c.guid! == g.guid || h &&! h.test (g.namespace) || d && d! == g.selector && ("**"! == d ||! g.selector) | | (m.splice (f, 1), g.selector && m.delegateCount -, l.remove && l.remove.call (a, g)); i &&! m.length && (l.teardown && l.teardown.call (a, p , r.handle)! ==! 1 || n.removeEvent (a, o, r.handle), exclua k [o])} else para (o em k) n.event.remove (a, o + b [j], c, d,! 0); n.isEmptyObject (k) && (excluir r.handle, n._removeData (a, "events"))}}, trigger: function (b, c, d, e ) {var f, g, h, i, k, l, m, o = [d || z], p = j.call (b, "tipo")? b.type: b, q = j.call (b, "namespace")? b.namespace.split ("."): []; if (h = l = d = d || z, 3! == d.nodeType && 8! == d.nodeType &&! _ .test (p + n.event.triggered) && (p.indexOf (".")> = 0 && (q = p.split ("."), p = q.shift (), q.sort ()) , g = p.indexOf (": ") <0 &&" on "+ p, b = b [n.expando]? B: new n.Event (p," objeto "== tipo de b && b), b.isTrigger = e? 2: 3, b. namespace = q.join ("."), b.namespace_re = b.namespace? new RegExp ("(^ | \\.)" + q.join ("\\. (?:. * \\. |) ") +" (\\. | $) "): null, b.result = void 0, b.target || (b.target = d), c = nulo == c? [b]: n.makeArray (c, [b]), k = n.event.special [p] || {}, e ||! k.trigger || k.trigger.apply (d, c)! ==! 1)) { if (! e &&! k.noBubble &&! n.isWindow (d)) {for (i = k.delegateType || p, _. test (i + p) || (h = h.parentNode); h; h = h.parentNode) o.push (h), l = h; l === (d.ownerDocument || z) && o.push (l.defaultView || l.parentWindow || a)} m = 0; while ( (h = o [m ++]) &&! b.isPropagationStopped ()) b.type = m> 1? i: k.bindType || p, f = (n._dados (h, "eventos") || {} ) [b.type] && n._data (h, "handle"), f && f.apply (h, c), f = g&&h [g], f&&f.aplicar && n.acceptData (h) && (b.result = f.apply (h, c), b.result ===! 1 && b.preventDefault ()); if (b.type = p,! e &&! b.isDefaultPrevented ( ) && (! k._default || k._default.apply (o.pop (), c) ===! 1) && n.acceptData (d) && g && d [p] &&! n.isWindow (d)) {l = d [g], l && (d [g] = nulo), n.event.triggered = p; tente {d [p] ()} catch (r) {} n.event.triggered = nulo 0, l && ( d [g] = l)} retornar b.result}}, despachar: function (a) {a = n.event.fix (a); var b, c, e, f, g, h = [], i = d.call (argumentos), j = (n._dados (isso, "eventos") || {}) [a.type] || [], k = n.event.special [a.type] || {}; if (i [0] = a, a.delegateTarget = this,! k.preDispatch || k.preDispatch.call (essa, a)! ==! 1) {h = n.event.handlers.call (this, a, j), b = 0; while ((f = h [b ++]) &&! a.isPropagationStopped ()) {a.currentTarget = f.elem, g = 0; while ((e = f. manipuladores [g ++]) &&! a.isImmediatePropagationStopped ()) (! a.namespace_re || a.namespace_re.test (e.namespace)) && (a.handleObj = e, a.data = e.data, c = ((n.event.special [e.origType] || {})). manipular || e.handler) .apply (f.elem, i), void 0! == c && (a.result = c) ===! 1 && (a.preventDefault (), a.stopPropagation ()))} return k.postDispatch && k.postDispatch.call (this, a), a.result}}, manipuladores: function (a, b) {var c, d, e, f, g = [], h = b.delegateCount, i = a.target; if (h && i.nodeType && (! a.button || "clique"! == a.type)) para (; i! = this; i = i.parentNode || this) if (1 == = i.nodeType && (i.disabled! ==! 0 || "clique"! == a.type)) {for (e = [], f = 0; h> f; f ++) d = b [f] , c = d.selector + "", void 0 === e [c] && (e [c] = d.needsContext? n (c, this) .index (i)> = 0: n.find (c, this, null, [i]). length), e [c] && e.push (d); e.length && g.push ({elem: i, manipuladores: e})} return h <b.length && g.push ({ elem: this, manipuladores: b.fatia (h)}), g}, correção: função (a) {if (a [n.expando]) retorna a; var b, c, d, e = a.type, f = a, g = this. fixHooks [e]; g || (this.fixHooks [e] = g = $. test (e)? this.mouseHooks: Z.test (e)? this.keyHooks: {}), d = g.props? this.props.concat (g.props): this.props, a = new n.Event (f), b = d.length; while (b -) c = d [b], a [c] = f [c]; retorna a.target || (a.target = f.srcElement || z), 3 === a.target.nodeType && (a.target = a.target.parentNode), a.metaKey = !! a.metaKey, g.filter? g.filter (a, f): a}, props: "altKey bolhas canceláveis ​​ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view what" .split (""), fixHooks: {}, keyHooks : {props: "char charCode key keyCode" .split (""), filter: function (a, b) {return null == a.which && (a.which = null! = b.charCode? b.charCode: b .keyCode), a}}, mouseHooks: {props: "botão botões clientX clientY fromElement offsetX offsetY páginaX screenX screenY toElement ".split (" "), filter: function (a, b) {var c, d, e, f = b.botão, g = b.fromElement; return null == a.pageX && null! = b.clientX && (d = a.target.ownerDocument || z, e = d.documentElement, c = d.body, a.pageX = b.clientX + (e && e.scrollLeft || c && c.scrollLeft || 0) - (e && e.clientLeft || c && c.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || c && c.scrollTop || 0) - (e && e.clientTop || c && c.clientTop | | 0)) ,! a.relatedTarget && g && (a.relatedTarget = g === a.target?b.toElement:g),a.which||void 0 === f || (a.which = 1 & f? 1 : 2 & f? 3: 4 & f? 2: 0), a}}, especial: {load: {noBubble:! 0}, foco: {trigger: function () {if (this! == db () && this.focus) tente {return this.focus () ,! 1} catch (a) {}}, delegateType: "focusin"}, blur:{trigger: function () {return this === db () && this.blur? (this.blur () ,! 1): void 0}, delegateType: "focusout"}, clique em: {trigger: function () { return n.nodeName (this, "input") && "checkbox" === this.type && this.click? (this.click () ,! 1): void 0}, _ padrão: function (a) {return n.nodeName (a.target, "a")}}, antes da descarga: {postDispatch: function (a) {void 0! == a.result && (a.originalEvent.returnValue = a.result)}}}, simule: function (a , b, c, d) {var e = n.extend (novo n.Evento, c, {tipo: a, isSimulated:! 0, originalEvent: {}}); d? n.event.trigger (e, null , b): n.event.dispatch.call (b, e), e.isDefaultPrevented () && c.preventDefault ()}}, n.removeEvent = função z.removeEventListener? (a, b, c) {a.removeEventListener && a .removeEventListener (b, c,! 1)}: function (a, b, c) {var d = "on" + b; a.detachEvent && (tipo de a [d] === L &&(a [d] = null), a.detachEvent (d, c))}, n.Event = function (a, b) {retorna esta instância de n.Event? (a && a.type? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && (a.returnValue ===! 1 || a.getPreventDefault && a.getPreventDefault ())? bb: cb): this.type = a, b && n.extend (this, b), this.timeStamp = a && a.timeStamp || n.now (), void (this [n.expando] =! 0)): novo n.Event (a , b)}, n.Event.prototype = {isDefaultPrevented: cb, isPropagationStopped: cb, isImmediatePropagationStopped: cb, preventDefault: function () {var a = this.originalEvent; this.isDefaultPrevented = bb, a && (a.prevent .preventDefault (): a.returnValue =! 1)}, stopPropagation: function () {var a = this.originalEvent; this.isPropagationStopped = bb, a && (a.stopPropagation && a.stopPropagation (), a.cancelBubble =! 0) }stopImmediatePropagation: function () {this.isImmediatePropagationStopped = bb, this.stopPropagation ()}}, n.each ({mouseenter: "mouseover", mouseleave: "mouseout"}, function (a, b) {n.event.special [a] = {delegateType: b, bindType: b, handle: function (a) {var c, d = this, e = a.relatedTarget, f = a.handleObj; return (! e || e! == d && ! n.contains (d, e)) && (a.type = f.origType, c = f.handler.apply (isto, argumentos), a.type = b), c}}}), l.submitBubbles | | (n.event.special.submit = {setup: function () {retorne n.nodeName (este, "formulário") ?! 1: void n.event.add (este, "clique._submit keypress._submit", função (a) {var b = a.target, c = n.nodeName (b, "entrada") || n.nodeName (b, "botão")? b.form: void 0; c &&! n._data ( c, "submitBubbles") && (n.event.add (c, "submit._submit", função (a) {a._submit_bubble =! 0}), n._dados (c, "submitBubbles ",! 0))})}, postDispatch: function (a) {a._submit_bubble && (exclua a._submit_bubble, this.parentNode &&! a.isTrigger && n.event.simulate (" submit ", this.parentNode, a ,! 0))}, teardown: function () {return n.nodeName (this, "form") ?! 1: void n.event.remove (this, "._ submit")}}), l.changeBubbles || ( n.event.special.change = {setup: function () {retornar Y.test (this.nodeName)? (("caixa de seleção" === this.type || "radio" === this.type) && ( n.event.add (isso, "mudança de propriedade._ mudança", função (a) {"marcada" === a.originalEvent.propertyName && (this.just_changed =! 0)}), n.event.add (this, " click._change ", function (a) {this._just_changed &&! a.isTrigger && (this._just_changed =! 1), n.event.simulate (" change ", this, a,! 0)})) ,! 1) : void n.event.add (this, "beforeactivate._change ", function (a) {var b = a.target; Y.test (b.nodeName) &&! n._data (b," changeBubbles ") && (n.event.add (b," change. _change ", function (a) {! this.parentNode || a.isSimulated || a.isTrigger || n.event.simulate (" alteração ", this.parentNode, a,! 0)}), n._dados ( b, "changeBubbles",! 0))})}, manipula: function (a) {var b = a.target; retorna isso! == b || a.isSimulated || a.isTrigger || "radio"! == b.type && "checkbox"! == b.type? a.handleObj.handler.apply (isto, argumentos): void 0}, teardown: function () {return n.event.remove (this, "._ change ") ,! Y.test (this.nodeName)}}), l.focusinBubbles || n.each ({focus:" focusin ", blur:" focusout "}, função (a, b) {var c = function (a) {n.event.simulate (b, a.target, n.event.fix (a) ,! 0)}; n.event.special [b] = {setup: function () {var d = this .ownerDocument || isto, e = n._data (d, b); e || d.addEventListener (a, c,! 0), n._data (d, b, (e || 0) +1)}, desmontagem: function () {var d = this.ownerDocument || this, e = n._data (d, b) -1; e? n._data (d, b, e) :( d.removeEventListener (a, c,! 0), n._removeData ( d, b))}}}), n.fn.extend ({on: function (a, b, c, d, e) {var f, g; if ("object" == typeof a) {"string "! = tipo de b && (c = c || b, b = nulo 0); para (f em a) isto. em (f, b, c, a [f], e); retorne isso} if (null = = c && nulo == d? (d = b, c = b = nulo 0): nulo == d && ("string" == tipo de b? (d = c, c = nulo 0) :( d = c, c = b, b = vazio 0)), d ===! 1) d = cb; caso contrário, se (! d) retorna isso; retorna 1 === e && (g = d, d = função (a) {return n ( ) .off (a), g.apply (this, argumentos)}, d.guid = g.guid || (g.guid = n.guid ++)), this.each (function () {n.event.add (this, a, d, c, b)})}, one: function (a, b, c, d) {retorna this.on (a, b, c, d, 1)}, off: function (a , b, c) {var d, e; if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n (a.delegateTarget) .off (d.namespace? d.origType + "." + d.namespace: d.origType, d.selector, d.handler), this; if ("object" == typeof a ) {for (e em a) this.off (e, b, a [e]); retorne isso} return (b ===! 1 || "function" == typeof b) && (c = b, b = void 0), c ===! 1 && (c = cb), this.each (function () {n.event.remove (this, a, c, b)})}, trigger: function (a, b ) {return this.each (function () {n.event.trigger (a, b, this)})}, triggerHandler: function (a, b) {var c = this [0]; return c? n.event .trigger (a, b, c,! 0): void 0}}); function eb (a) {var b = fb.split ("|"), c = a.createDocumentFragment (); if (c.createElement ) while (b.length) c.createElement (b.pop ()); return c} var fb = "abbr | article | aparte | audio | bdi | canvas | data | datalist | detalhes | figcaption | figure | footer | header | hgroup | mark | meter | nav | output | progress | section | summary | time | video ", gb = / jQuery \ d + =" (?:null | \ d +) "/ g, hb = new RegExp (" <(?: "+ fb +") [\\ s />] "," i "), ib = / ^ \ s + /, jb = / < (?! area | br | col | embed | hr | img | input | link | meta | param) (([\ w:] +) [^>] *) \ /> / gi, kb = / <([ \ w:] +) /, lb = / <tbody / i, mb = / <| & #? \ w +; /, nb = / <(?: script | estilo | link) / i, ob = / verificado \ s * (?: [^ =] | = \ s *. checado.) / i, pb = / ^ $ | \ / (?: java | ecma) script / i, qb = / ^ verdadeiro \ / (. * ) /, rb = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g, sb = {opção: [ 1, "<selecione multiple = 'multiple'>", "</select>"], legenda: [1, "<fieldset>", "</fieldset>"], área: [1, "<map>" , "</map>"], param: [1, "<object>", "</object>"], thead: [1, "<table>", "</table>"], tr: [ 2, "<table> <tbody>", "</tbody> </table>"],col: [2, "<table> <tbody> </tbody> <colgroup>", "</colgroup> </table>"], td: [3, "<table> <tbody> <tr>", "</tr> </tbody> </table>"], _ padrão: l.htmlSerializar? [0, "", ""]: [1, "X <div>", "</div>"]} , tb = eb (z), ub = tb.appendChild (z.createElement ("div")); sb.optgroup = sb.option, sb.tbody = sb.tfoot = sb.colgroup = sb.caption = sb. thead, sb.th = sb.td; função vb (a, b) {var c, d, e = 0, f = tipo de a.getElementsByTagName! == L? a.getElementsByTagName (b || "*"): tipo de a.querySelectorAll! == L? a.querySelectorAll (b || "*"): void 0; if (! f) for (f = []] c = a.childNodes || a; null! = (d = c [e]); e ++)! b || n.nodeName (d, b)? f.push (d): n.merge (f, vb (d, b)); return void 0 === b || b && n.nodeName (a, b)? n.merge ([a], f): f} função wb (a) {X.test (a.tipo) && (a.defaultChecked = a.checked)} função xb (a, b) {retornar n.nodeName (a, "tabela") && n.nodeName (11! == b.nodeType? b: b.firstChild, "tr")? a.getElementsByTagName ("tbody") [0] || a.appendChild (a.ownerDocument.createElement ("tbody")): a} função yb (a) {return a.type = (null! == n.find.attr (a, "tipo")) + "/" + a.type, a} função zb (a) {var b = qb.exec (a.type); return b? a.type = b [1]: a.removeAttribute ("tipo"), a} função Ab (a, b) {para (var c, d = 0; nulo! = (c = a [d]); d ++) n. _dados (c, "globalEval",! b || n._data (b [d], "globalEval")))} função Bb (a, b) {if (1 === b.nodeType && n.hasData (a)) {var c, d, e, f = n._dados (a), g = n._dados (b, f), h = f.eventos; se (h) {excluir g.handle, g.events = {} ; for (c em h) para (d = 0, e = h [c] .length; e> d; d ++) n.event.add (b, c, h [c] [d])} g.data && (g.data = n.extend ({}, g.data))}} função Cb (a, b) {var c, d, e; if (1 === b.nodeType) {if (c = b.nodeName.toLowerCase () ,! l.noCloneEvent && b [n. expando]) {e = n._dados (b); para (d em e.eventos) n.removeEvent (b, d, e.handle); b.removeAttribute (n.expando)} "script" === c && b .text! == a.text? (yb (b) .text = a.text, zb (b)): "objeto" === c? (b.parentNode && (b.outerHTML = a.outerHTML), l .html5Clone && a.innerHTML &&! n.trim (b.innerHTML) && (b.innerHTML = a.innerHTML)): "input" === c && X.test (a.type)? (b.defaultChecked = b.checked = a .checked, b.value! == a.value && (b.value = a.value)): "opção" === c? b.defaultSelected = b.selected = a.defaultSelected :( "input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue)}} n.extend ({clone: ​​function (a, b, c) {var d, e, f, g, h, i = n.contains (a.ownerDocument, a); if (l.html5Clone || n.isXMLDoc (a) ||!hb.test ("<" + a.nodeName + ">")? f = a.cloneNode (! 0) :( ub.innerHTML = a.outerHTML, ub.removeChild (f = ub.firstChild)),! (l .noCloneEvent && l.noCloneChecked || 1! == a.nodeType && 11! == a.nodeType || n.isXMLDoc (a))) para (d = vb (f), h = vb (a), g = 0; null ! = (e = h [g]); ++ g) d [g] && Cb (e, d [g]); se (b) se (c) para (h = h || vb (a), d = d || vb (f), g = 0; nulo! = (e = h [g]); g ++) Bb (e, d [g]); caso contrário, Bb (a, f); return d = vb ( f, "script"), d.length> 0 && Ab (d,! i && vb (a, "script")), d = h = e = nulo, f}, buildFragment: function (a, b, c, d) { Para (var e, f, g, h, i, j, k, m = a.length, o = eb (b), p = [], q = 0; m> q; q ++) if (f = a [q], f || 0 === f) if ("objeto" === n.type (f)) n.merge (p, f.nodeType? [f]: f); caso contrário, se (mb. teste (f)) {h = h || o.appendChild (b.createElement ("div")), i = (kb.exec (f) || ["", ""]) [1] .toLowerCase ( ), k = sb [i] || sb._default, h.innerHTML = k [1] + f.replace (jb,"<$ 1> </ $ 2>") + k [2], e = k [0]; while (e -) h = h.lastChild; if (! L.leadingWhitespace && ib.test (f) && p.push ( b.createTextNode (ib.exec (f) [0]))! l.tbody) {f = "tabela"! == i || lb.test (f)? "<table>"! == k [ 1] || lb.test (f)? 0: h: h.firstChild, e = f && f.childNodes.length; while (e -) n.nodeName (j = f.childNodes [e], "tbody") &&! j.childNodes.length && f.removeChild (j)} n.merge (p, h.childNodes), h.textContent = ""; while (h.firstChild) h.removeChild (h.firstChild); h = o. lastChild} else p.push (b.createTextNode (f)); h && o.removeChild (h), l.appendChecked || n.grep (vb (p, "entrada"), wb), q = 0; while (f = p [q ​​++]) if ((! d || -1 === n.inArray (f, d)) && (g = n.contains (f.ownerDocument, f), h = vb (o.appendChild ( f), "script"), g&& Ab (h), c)) {e = 0; enquanto (f = h [e ++]) pb.test (f.type || "") && c.push (f)} retorna h = nulo, o}, cleanData: function (a, b) {for (var d, e, f, g, h = 0, i = n.expando, j = n.cache, k = l.deleteExpando, m = n.event.special; null! = (d = a [h]); h ++) if ((b || n.acceptData (d)) && (f = d [i], g = f && j [f])) {if (g.events) para (e em g.events) m [e]? n.event.remove (d, e): n.removeEvent (d, e, g.handle) ; j [f] && (excluir j [f], k? excluir d [i]: tipo de d.removeAttribute! == L? d.removeAttribute (i): d [i] = nulo, c.push (f) )}}}), n.fn.extend ({text: function (a) {return W (this, function (a) {return void 0 === a? n.text (this): this.empty () .append ((this [0] && this [0] .ownerDocument || z) .createTextNode (a))}, null, a, argument.length)}, anexa: function () {retorna this.domManip (argumentos, função (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = xb (isto, a); b.appendChild (a)} })}, prepend: function () {retorna this.domManip (argumentos, função (a) {if (1 === this.nodeType || 11 === this).nodeType || 9 === this.nodeType) {var b = xb (this, a); b.insertBefore (a, b.firstChild)}})}, before: function () {return this.domManip (argumentos, function (a) {this.parentNode && this.parentNode.insertBefore (a, this)})}, after: function () {return this.domManip (argumentos, função (a) {this.parentNode && this.parentNode.insertBefore (a, this .nextSibling)})}, remove: function (a, b) {for (var c, d = a? n.filter (a, this): this, e = 0; null! = (c = d [e] ); e ++) b || 1! == c.nodeType || n.cleanData (vb (c)), c.parentNode && (b && n.contains (c.ownerDocument, c) && Ab (vb (c, "script")) ), c.parentNode.removeChild (c)); retorna isso, vazio: function () {for (var a, b = 0; null! = (a = this [b]); b ++) {1 === a.nodeType && n.cleanData (vb (a,! 1)); while (a.firstChild) a.removeChild (a.firstChild); a.options && n.nodeName (a, "select") && (a.options.length = 0)} retorne isso}, clone:função (a, b) {retornar a = null == a?! 1: a, b = null == b? a: b, this.map (function () {retornar n.clone (this, a, b) })}, html: function (a) {return W (this, function (a) {var b = this [0] || {}, c = 0, d = this.length; if (void 0 === a) return 1 === b.nodeType? b.innerHTML.replace (gb, ""): void 0; if (! ("string"! = tipo de a || nb.test (a) ||! l. htmlSerialize && hb.test (a) ||! l.leadingWhitespace && ib.test (a) || sb [(kb.exec (a) || ["", ""]) [1] .toLowerCase ()])) {a = a.replace (jb, "<$ 1> </ $ 2>"); tente {for (; d> c; c ++) b = este [c] || {}, 1 === b.nodeType && (n. cleanData (vb (b,! 1)), b.innerHTML = a); b = 0} catch (e) {}} b && this.empty (). append (a)}, null, a, argument.length)} , substituaWith: function () {var a = argumentos [0]; retorne this.domManip (argumentos, função (b) {a = this.parentNode, n.cleanData (vb (this)), a && a.replaceChild (b, this )}), a && (a.length || a.nodeType)? this: this.remove ()}, desanexa: function (a) {retorna this.remove (a,! 0)}, domManip: function (a, b) {a = e.apply ([], a ); var c, d, f, g, h, i, j = 0, k = this.length, m = this, o = k-1, p = a [0], q = n.isFunção (p) ; if (q || k> 1 && "string" == tipo de p &&! l.checkClone && ob.test (p)) retorna this.each (function (c) {var d = m.eq (c); q && (a [ 0] = p.call (this, c, d.html ())), d.domManip (a, b)}); if (k && (i = n.buildFragment (a, este [0] .ownerDocument ,! 1, this), c = i.firstChild, 1 === i.childNodes.length && (i = c), c)) {for (g = n.map (vb (i, "script"), yb), f = g.length; k> j; j ++) d = i, j! == o && (d = n.clone (d,! 0,! 0), f && n.merge (g, vb (d, "script" ))), b.call (this [j], d, j); if (f) for (h = g [g.length-1] .ownerDocument, n.map (g, zb), j = 0; f> j; j ++) d = g [j], pb.test (d.type || "") &&! n._data (d, "globalEval") && n.contains (h, d) &&(d.src? n._evalUrl && n._evalUrl (d.src): n.globalEval ((d.text || d.textContent || d.innerHTML || ""). replace (rb, "")); i = c = null} retorne isso}}, n.each ({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith"}, function ( a, b) {n.fn [a] = função (a) {para (var c, d = 0, e = [], g = n (a), h = g.length-1; h> = d ; d ++) c = d === h? this: this.clone (! 0), n (g [d]) [b] (c), f.apply (e, c.get ()); .pushStack (e)}}); var Db, Eb = {}; função Fb (b, c) {var d = n (c.createElement (b)). appendTo (c.body), e = a.getDefaultComputedStyle ? a.getDefaultComputedStyle (d [0]). display: n.css (d [0], "display"); retorna d.detach (), e} função Gb (a) {var b = z, c = Eb [a]; retornar c || (c = Fb (a, b), "nenhum"! == c && c || (Db = (Db || n ("<iframe frameborder = '0' width = '0' height = '0 '/> ")). AppendTo (b.documentElement), b = (Db [0] .contentWindow || Db [0] .contentDocument) .document, b.write (), b.close (), c = Fb (a, b), Db.detach ()), Eb [a] = c), c}! Function () {var a, b, c = z.createElement ("div"), d = "- webkit -box-dimensionamento: caixa de conteúdo; -moz-box-dimensionamento: caixa de conteúdo; caixa-dimensionamento: caixa de conteúdo; exibição: bloco; preenchimento: 0; margem: 0; borda: 0 "; c.innerHTML =" <link/><table> </table> <a href='/a'> a </a> <input type = 'checkbox' /> ", a = c.getElementsByTagName (" a ") [0], a.style.cssText = "flutuação: esquerda; opacidade: 0,5", l.opacidade = / ^ 0,5 / .test (a.style.opacidade), l.cssFloat = !! a.style.cssFloat, c.style .backgroundClip = "caixa de conteúdo", c.cloneNode (! 0) .style.backgroundClip = "", l.clearCloneStyle = "caixa de conteúdo" === c.style.backgroundClip, a = c = nulo, l.shrinkWrapBlocks = function () {var a, c, e, f; if (null == b) {if (a = z.getElementsByTagName ("body") [0] ,! a) return; f = "border: 0 ; width: 0; height: 0; position: absolute; top: 0; left: -9999px ", c = z.createElement (" div "), e = z.createElement (" div "), a.appendChild (c ) .appendChild (e), b =! 1, tipo de e.style.zoom! == L && (e.style.cssText = d + "; largura: 1px; preenchimento: 1px; zoom: 1", e.innerHTML = " <div> </div> ", e.firstChild.style.width =" 5px ", b = 3! == e.offsetWidth), a.removeChild (c), a = c = e = null} retorno b} } (); var Hb = / ^ margem /, Ib = new RegExp ("^ (" + T + ") (?! px) [az%] + $", "i"), Jb, Kb, Lb = / ^ (superior | direita | inferior | esquerda) $ /; a.getComputedStyle? (Jb = função (a) {retorna a.ownerDocument.defaultView.getComputedStyle (a, null)}, Kb = function (a, b, c) {var d, e, f, g, h = a.style; retornar c = c || Jb (a), g = c? c.getPropertyValue (b) || c [b]:void 0, c && (""! == g || n.contains (a.ownerDocument, a) || (g = n.style (a, b)), Ib.test (g) && Hb.test (b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g? g: g + ""}): z.documentElement.currentStyle && (Jb = function (a) {retornar a.currentStyle}, Kb = function (a, b, c) {var d, e, f, g, h = a.style; retorno c = c || Jb (a), g = c? c [b]: nulo 0, nulo == g && h && h [b] && (g = h [b]), Ib.test (g) &&! Lb.test (b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (e.left = a.currentStyle.left), h.left = "fontSize" === b? "1em": g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)), void 0 === g? g: g + "" || "auto"}); função Mb (a, b) {return {get: function () {var c = a (); if (null! = c) return c? void exclua this.get: (isto.get = b) .apply (this, argumentos)}}}! function () {var b, c, d, e, f, g, h = z.createElement ("div"), i = "border: 0; largura: 0; altura: 0; posição: absoluto; em cima: 0; esquerda: -9999px ", j =" - dimensionamento de caixa da webkit: caixa de conteúdo; dimensionamento de caixa de moz: dimensionamento de caixa; dimensionamento de caixa : content-box; display: block; padding: 0; margin: 0; border: 0 "; h.innerHTML =" <link/><table> </table> <a href='/a'> a </ a> <tipo de entrada = 'caixa de seleção' /> ", b = h.getElementsByTagName (" a ") [0], b.style.cssText =" flutuante: esquerda; opacidade: 0,5 ", l.opacidade = / ^ 0.5 / .test (b.style.opacidade), l.cssFloat = !! b.style.cssFloat, h.style.backgroundClip = "caixa de conteúdo", h.cloneNode (! 0) .style.backgroundClip = "" , l.clearCloneStyle = "content-box" === h.style.backgroundClip, b = h = null, n.extend (l, {reliableHiddenOffsets: function () {if (null! = c) retorna c; var a bd, e = z.createElement ("div"), f = z.getElementsByTagName ("body") [0]; se (f) retornar e.setAttribute ("className", "t"), e.innerHTML = " <link/><table> </table> <a href='/a'> a </a> <input type = 'checkbox' /> ", a = z.createElement (" div "), a.style .cssText = i, f.appendChild (a) .appendChild (e), e.innerHTML = "<table> <tr> <td> </td> <td> t </td> </tr> </ table > ", b = e.getElementsByTagName (" td "), b [0] .style.cssText =" preenchimento: 0; margem: 0; borda: 0; exibição: nenhuma ", d = 0 === b [0 ] .offsetHeight, b [0] .style.display = "", b [1] .style.display = "nenhum", c = d && 0 === b [0] .offsetHeight, f.removeChild (a), e = f = nulo, c}, boxSizing: function () {return null == d && k (), d}, boxSizingReliable: function () {return null == e && k (), e}, pixelPosition: function () {return null == f && k (), f}, reliableMarginRight: function () {var b, c, d, e; if (null == g && a.getComputedStyle) {if (b = z.getElementsByTagName ("corpo") [0] ,! b) return; c = z.createElement ("div"), d = z.createElement ("div"), c.style.cssText = i, b.appendChild (c) .appendChild (d), e = d.appendChild (z.createElement ("div")), e.style.cssText = d.style.cssText = j, e.style.marginRight = e. style.width = "0", d.style.width = "1px", g =! parseFloat ((a.getComputedStyle (e, null) || {}) .| }}); função k () {var b, c, h = z.getElementsByTagName ("body") [0]; h && (b = z.createElement ("div"), c = z.createElement ("div" ), b.style.cssText = i, h.appendChild (b) .appendChild (c), c.style.cssText = "- dimensionamento de caixa de kit da Web: borda da caixa; ;tamanho da caixa: caixa-borda; posição: absoluto; exibição: bloco; preenchimento: 1px; borda: 1px; largura: 4px; margem superior: 1%; superior: 1% ", n.swap (h, null! = h.style.zoom? {zoom: 1}: {}, function () {d = 4 === c.offsetWidth}), e =! 0, f =! 1, g =! 0, a.getComputedStyle && ( f = "1%"! == (a.getComputedStyle (c, nulo) || {}). top, e = "4px" === (a.getComputedStyle (c, nulo) || {width: "4px "}). largura), h.removeChild (b), c = h = nulo)}} (), n.swap = function (a, b, c, d) {var e, f, g = {}; for (f in b) g [f] = a.style [f], a.style [f] = b [f]; e = c.aplicar (a, d || []); for (f em b ) a.style [f] = g [f]; retorna e}; var Nb = / alpha \ ([^)] * \) / i, Ob = / opacidade \ s * = \ s * ([^)] *) /, Pb = / ^ (nenhuma | tabela (?! - c [ea]). +) /, Qb = novo RegExp ("^ (" + T + ") (. *) $", "I") , Rb = new RegExp ("^ ([+ -]) = (" + T + ")", "i"), Sb = {posição: "absoluta", visibilidade: "oculta", exibição: "bloco"}, Tb = {letterSpacing:0, fontWeight: 400}, Ub = ["Webkit", "O", "Moz", "ms"]; função Vb (a, b) {se (b em a) retornar b; var c = b.charAt (0) .toUpperCase () + b.slice (1), d = b, e = Ub.length; while (e -) if (b = Ub [e] + c, b em a) retornam b; return d} função Wb (a, b) {para (var c, d, e, f = [], g = 0, h = comprimento.a; h> g; g ++) d = a [g], estilo e estilo (f [g] = n._dados (d, "exibição antiga"), c = d.style.display, b? (f [g] || "nenhum"! == c || (d.style.display = ""), "" === exibição de d.style.d & exibição de V & (d) && (f [g] = dados n. (d, "exibição antiga", Gb (d.nodeName)))): f [g] || (e = V (d), (c && "nenhum"! == c ||! e) && n._data (d, "exibição antiga", e? c: n.css (d, "exibição")))); para (g = 0; h> g; g ++) d = a [g], estilo d && (b && "nenhum"! == d.style.display && ""! == d.style.display || (d. style.display = b? f [g] || "": "nenhum ")); retorna uma função} Xb (a, b, c) {var d = Qb.exec (b); retorna d? Math.max (0, d [1] - (c || 0)) + (d [2] || "px"): b} função Yb (a, b, c, d, e) {para (var f = c === (d? "borda": "conteúdo")? 4 : "largura" === b? 1: 0, g = 0; 4> f; f + = 2) "margem" === c && (g + = n.css (a, c + U [f] ,! 0 , e)), d? ("conteúdo" === c && (g- = n.css (a, "preenchimento" + U [f] ,! 0, e)), "margem"! == c && (g - = n.css (a, "borda" + U [f] + "Largura",! 0, e))) :( g + = n.css (a, "preenchimento" + U [f] ,! 0, e), "padding"! == c && (g + = n.css (a, "borda" + U [f] + "largura",! 0, e))); retornar g} função Zb (a, b, c) {var d =! 0, e = "width" === b? a.offsetWidth: a.offsetHeight, f = Jb (a), g = l.boxSizing () && "border-box" === n.css (a, "boxSizing",! 1, f); if (0> = e || null == e) {if (e = Kb (a, b, f), (0> e || null == e) &&(e = a.style [b]), Ib.test (e)) retorna e; d = g && (l.boxSizingReliable () || e === a.style [b]), e = parseFloat (e) || 0} retornar e + Yb (a, b, c || (g? "Borda": "conteúdo"), d, f) + "px"} n.extend ({cssHooks: {opacidade: {get: função (a, b) {se (b) {var c = Kb (a, "opacidade"); retornar "" === c? "1": c}}}}, cssNumber: {columnCount:! 0, fillOpacity:! 0, fontWeight:! 0, lineHeight:! 0, opacidade:! 0, ordem:! 0, órfãos:! 0, viúvas:! 0, zIndex:! 0, zoom:! 0}, cssProps: {" float ": l.cssFloat?" cssFloat ":" styleFloat "}, style: function (a, b, c, d) {if (a && 3! == a.nodeType && 8! == a.nodeType && a.style) {var e , f, g, h = n.camelCase (b), i = a.style; if (b = n.cssProps [h] || (n.cssProps [h] = Vb (i, h)), g = n.cssHooks [b] || n.cssHooks [h], void 0 === c) retornar g && "get" em g && void 0! == (e = g.get (a,! 1, d))? e : i [b]; if (f = tipo de c, "string "=== f && (e = Rb.exec (c)) && (c = (e [1] +1) * e [2] + parseFloat (n.css (a, b)), f =" número "), null! = c && c === c && (" número "! == f || n.cssNúmero [h] || (c + =" px "), l.clearCloneStyle ||" "! == c || 0! == b.indexOf ("background") || (i [b] = "herdar"),! (G && "conjunto" em g && void 0 === (c = g.set (a, c, d) )))) tente {i [b] = "", i [b] = c} captura (j) {}}}, css: function (a, b, c, d) {var e, f, g, h = n.camelCase (b); return b = n.cssProps [h] || (n.cssProps [h] = Vb (a.style, h)), g = n.cssHooks [b] || n. cssHooks [h], g && "get" em g && (f = g.get (a,! 0, c)), nulo 0 === f && (f = Kb (a, b, d)), "normal" = == f && b em Tb && (f = Tb [b]), "" === c || c? (e = parseFloat (f), c ===! 0 || n.isNumérico (e)? e || 0: f): f}}), n.each (["height", "width"], função (a, b) {n.cssHooks [b] = {get:função (a, c, d) {return c? 0 === a.offsetWidth && Pb.test (n.css (a, "display"))? n.swap (a, Sb, function () {return Zb (a , b, d)}): Zb (a, b, d): void 0}, set: function (a, c, d) {var e = d && Jb (a); retorna Xb (a, c, d? Yb (a, b, d, l.boxSizing () && "border-box" === n.css (a, "boxSizing",! 1, e), e): 0)}}}), l.opacidade || (n.cssHooks.opacity = {get: function (a, b) {return Ob.test ((b && a.currentStyle? a.currentStyle.filter: a.style.filter) || "")). 01 * parseFloat (RegExp. $ 1) + "": b? "1": ""}, defina: função (a, b) {var c = a.style, d = a.currentStyle, e = n.isNumeric (b) ? "alpha (opacidade =" + 100 * b + ")": "", f = d && d.filter || c.filter || ""; c.zoom = 1, (b> = 1 || "" == = b) && "" === n.trim (substitua (Nb, "")) && c.removeAttribute && (c.removeAttribute ("filtro ")," "=== b || d &&! d.filter) || (c.filter = Nb.test (f)? f.replace (Nb, e): f +" "+ e)}}) , n.cssHooks.marginRight = Mb (l.reliableMarginRight, função (a, b) {return b? n.swap (a, {display: "inline-block"}, Kb, [a, marginRight "]): vazio 0}), n.each ({margin: "", padding: "", border: "Width"}, função (a, b) {n.cssHooks [a + b] = {expand: function (c) {for (var d = 0, e = {}, f = "string" == tipo de c? c.split (""): [c]; 4> d; d ++) e [a + U [d] + b] = f [d] || f [d-2] || f [0]; retorna e}}, Hb.test (a) || (n.cssHooks [a + b] .set = Xb)} ), n.fn.extend ({css: function (a, b) {return W (this, function (a, b, c) {var d, e, f = {}, g = 0; if (n. isArray (b)) {for (d = Jb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g] ,! 1, d ); return f} return void 0! == c? n.style (a, b, c): n.css (a, b)f + "" + e)}}), n.cssHooks.marginRight = Mb (l.reliableMarginRight, função (a, b) {return b? n.swap (a, {display: "inline-block"}, Kb, [a, "marginRight"]): void 0}), n.each ({margin: "", padding: "", border: "Width"}, função (a, b) {n.cssHooks [a + b ] = {expand: function (c) {for (var d = 0, e = {}, f = "string" == tipo de c? c.split (""): [c]; 4> d; d ++) e [a + U [d] + b] = f [d] || f [d-2] || f [0]; retorno e}}, Hb.test (a) || (n.cssHooks [a + b] .set = Xb)}), n.fn.extend ({css: function (a, b) {retorna W (esta, função (a, b, c) {var d, e, f = {} , g = 0; if (n.isArray (b)) {for (d = Jb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g] ,! 1, d); return f} return void 0! == c? n.style (a, b, c): n.css (a, b)f + "" + e)}}), n.cssHooks.marginRight = Mb (l.reliableMarginRight, função (a, b) {return b? n.swap (a, {display: "inline-block"}, Kb, [a, "marginRight"]): void 0}), n.each ({margin: "", padding: "", border: "Width"}, função (a, b) {n.cssHooks [a + b ] = {expand: function (c) {for (var d = 0, e = {}, f = "string" == tipo de c? c.split (""): [c]; 4> d; d ++) e [a + U [d] + b] = f [d] || f [d-2] || f [0]; retorno e}}, Hb.test (a) || (n.cssHooks [a + b] .set = Xb)}), n.fn.extend ({css: function (a, b) {retorna W (esta, função (a, b, c) {var d, e, f = {} , g = 0; if (n.isArray (b)) {for (d = Jb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g] ,! 1, d); return f} return void 0! == c? n.style (a, b, c): n.css (a, b)each ({margin: "", padding: "", border: "Width"}, função (a, b) {n.cssHooks [a + b] = {expand: function (c) {for (var d = 0 , e = {}, f = "string" == tipo de c? c.split (""): [c]; 4> d; d ++) e [a + U [d] + b] = f [d] || f [d-2] || f [0]; retorno e}}, Teste Hb (a) || (n.cssHooks [a + b] .set = Xb)}), n.fn.extend ({css: function (a, b) {return W (this, function (a, b, c) {var d, e, f = {}, g = 0; if (n.isArray (b)) {para (d = Jb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g] ,! 1, d); return f} return void 0! == c? N.style (a, b, c): n.css (a, b)each ({margin: "", padding: "", border: "Width"}, função (a, b) {n.cssHooks [a + b] = {expand: function (c) {for (var d = 0 , e = {}, f = "string" == tipo de c? c.split (""): [c]; 4> d; d ++) e [a + U [d] + b] = f [d] || f [d-2] || f [0]; retorno e}}, Teste Hb (a) || (n.cssHooks [a + b] .set = Xb)}), n.fn.extend ({css: function (a, b) {return W (this, function (a, b, c) {var d, e, f = {}, g = 0; if (n.isArray (b)) {para (d = Jb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g] ,! 1, d); return f} return void 0! == c? N.style (a, b, c): n.css (a, b)g = 0; if (n.isArray (b)) {para (d = Jb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g] ,! 1, d); return f} return void 0! == c? n.style (a, b, c): n.css (a, b)g = 0; if (n.isArray (b)) {para (d = Jb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g] ,! 1, d); return f} return void 0! == c? n.style (a, b, c): n.css (a, b)
}, a, b, argument.length> 1)}, show: function () {retorna Wb (this,! 0)}, hide: function () {retorna Wb (this)}, alterna: function (a) { retornar "booleano" == tipo de a? a? this.show (): this.hide (): this.each (function () {V (this)? n (this) .show (): n (this). hide ()})}}); function $ b (a, b, c, d, e) {retorna novo $ b.prototype.init (a, b, c, d, e)} n.Tween = $ b , $ b.prototype = {construtor: $ b, init: função (a, b, c, d, e, f) {this.elem = a, this.prop = c, this.easing = e || "swing ", this.options = b, this.start = this.now = this.cur (), this.end = d, this.unit = f || (n.cssNumber [c]?" ":" px ") }, cur: function () {var a = $ b.propHooks [this.prop]; retorna um && a.get? a.get (this): $ b.propHooks._default.get (this)}, execute: function ( a) {var b, c = $ b.propHooks [this.prop]; retorna this.pos = b = this.options.duration? n.easing [this.easing] (a, this.options.duration * a, 0,1, this.options.duration): a, this.now = (this.end-this.start) * b + this.start, this.options.step && this.options.step.call (this.elem, this.now, this), c && c.set? c.set (this): $ b.propHooks._default. set (this), this}}, $ b.prototype.init.prototype = $ b.prototype, $ b.propHooks = {_ padrão: {get: function (a) {var b; return null == a.elem [ a.prop] || a.elem.style && null! = a.elem.style [aprop]? (b = n.css (a.elem, a.prop, ""), b && "auto"! == b? b: 0): a.elem [a.prop]}, defina: function ( a) {n.fx.step [a.prop]? n.fx.step [a.prop] (a): a.elem.style && (null! = a.elem.style [n.cssProps [a.prop ]] || n.cssHooks [a.prop])? n.style (a.elem, a.prop, a.now + a.unit): a.elem [a.prop] = a.now}}} , $ b.propHooks.scrollTop = $ b.propHooks.scrollLeft = {conjunto: função (a) {a.elem.nodeType && a.elem.parentNode && (a.elem [a.prop] = a.now)}}, n .easing = {linear: função (a) {retornar a}, swing: função (a) {return.5-Math.cos (a * Math.PI) / 2}}, n.fx = $ b.prototype. init, n.fx.step = {}; var _b, ac, bc = / ^ (?: alternar | mostrar | ocultar) $ /, cc = new RegExp ("^ (?: ([+ -]) = | ) ("+ T +") ([az%] *) $ "," i "), dc = / queueHooks $ /, ec = [jc], fc = {" * ": [function (a, b) { var c = this.createTween (a, b), d = c.cur (), e = cc.exec (b), f = e && e [3] || (n.cssNúmero [a]? "": "px "), g = (n.cssNumber [a] || "px"! == f && + d) && cc.exec (n.css (c.elem, a)), h = 1, i = 20; se (g && g [3]! == f ) {f = f || g [3], e = e || [], g = + d || 1; faça h = h || ".5", g / = h, n.style (c. elem, a, g + f); while (h! == (h = c.cur () / d) && 1! == h && - i)} retornar e && (g = c.start = + g || + d || 0, c.unidade = f, c.end = e [1]? g + (e [1] +1) * e [2]: + e [2]), c}]}; função gc ( ) {return setTimeout (function () {_ b = void 0}), _ b = n.now ()} função hc (a, b) {var c, d = {height: a}, e = 0; for (b = b? 1: 0; 4> e; e + = 2-b) c = U [e], d ["margem" + c] = d ["preenchimento" + c] = a; retorno b && (d.opacidade = d.width = a), d} função ic (a, b, c) {for (var d, e = (fc [b] || []). concat (fc ["*"]), f = 0, g = e.length; g> f; f ++) if (d = e [f] .call (c, b, a)) return d} função jc (a, b, c) {var d, e, f, g, h, i, j, k, m = isto, o = {}, p = a.style, q = a.nodeType && V (a), r = n._dados (a, "fxshow"); c .queue || (h = n._queueHooks (a, "fx"), nulo == h.sem fila && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {h.unqueued || i ()}), h.unqueued ++, m.always (function () {m .always (function () {h.unqueued -, n.ueue (a, "fx"). length || h.empty.fire ()})})), 1 === a.nodeType && ("height "in b ||" width "em b) && (c.overflow = [p.overflow, p.overflowX, p.overflowY]], j = n.css (a," exibição "), k = Gb (a. nodeName), "none" === j && (j = k), "inline" === j && "none" === n.css (a, "float") && (l.inlineBlockNeedsLayout && "inline"! == k? p.zoom = 1: p.display = "bloco em linha")), c.overflow && (p.overflow = "oculto", l.shrinkWrapBlocks () || m.always (function () {p.overflow = c.overflow [0], p.overflowX = c.overflow [1], p.overflowY = c.overflow [2]})); para (d em b) se (e = b [d], bc. exec (e)) {if (excluir b [d], f = f || "alternar"=== e, e === (q? "ocultar": "mostrar")) {if ("mostrar"! == e ||! r || vazio 0 === r [d]) continue; q =! 0} o [d] = r && r [d] || n.style (a, d)} if (! N.isEmptyObject (o)) {r? "Oculto" em r && (q = r.hidden): r = n._dados (a, "fxshow", {}), f && (r.hidden =! q), q? n (a) .show (): m.done (função () {n (a). hide ()}), m.done (function () {var b; n._removeData (a, "fxshow"); para (b in o) n.style (a, b, o [b])}); para (d in o) g = ic (q? r [d]: 0, d, m), d em r || (r [d] = g.start, q && (g.end = g.start, g .start = "width" === d || "height" === d? 1: 0))}} função kc (a, b) {var c, d, e, f, g; for (c em a) se (d = n.camelCase (c), e = b [d], f = a [c], n.isArray (f) && (e = f [1], f = a [c] = f [0]), c! == d && (a [d] = f, exclua a [c]), g = n.cssHooks [d], g && "expanda" em g) {f = g.expand (f) , exclua a [d]; para (c em f) c em a || (a [c] = f [c], b [c] = e)} else b [d] = e} função lc (a, b, c) {var d, e, f = 0,g = ec.length, h = n.Deferido (). sempre (função () {excluir i.elem}), i = função () {se (e) retornar! 1; para (var b = _b || gc (), c = Math.max (0, j.startTime + j.duration-b), d = c / j.duration || 0, f = 1-d, g = 0, i = j.tweens.length ; i> g; g ++) j.tweens [g] .run (f); return h.notifyWith (a, [j, f, c]), 1> f &&i? c: (h.resolveWith (a, [j ]) ,! 1)}, j = h.promise ({elem: a, props: n.extend ({}, b), opta: n.extend (! 0, {specialEasing: {}}, c), originalProperties: b, originalOptions: c, startTime: _b || gc (), duração: c.duration, tweens: [], createTween: function (b, c) {var d = n.Tween (a, j.opts, b, c, j.opts.specialEasing [b] || j.opts.easing); return j.tweens.push (d), d}, stop: function (b) {var c = 0, d = b? j.tweens.length: 0; se (e) retornar isso; para (e =! 0; d> c; c ++) j.tweens [c] .run (1); return b? h.resolveWith (a, [ j, b]): h.rejectWith (a, [j, b]), este}}), k = j.props; for (kc (k, j.opts.specialEasing); g> f; f ++) se (d = ec [f] .call (j, a, k, j.opts)) return d; return n.map (k,ic, j), n.isFunction (j.opts.start) && j.opts.start.call (a, j), n.fx.timer (n.extend (i, {elem: a, anim: j, fila : j.opts.queue})), j.progress (j.opts.progress). concluído (j.opts.done, j.opts.complete) .fail (j.opts.fail) .always (j.opts .sempre)} n.Animation = n.extend (lc, {interpolador: function (a, b) {n.isFunção (a)? (b = a, a = ["*"]): a = a.split (""); para (var c, d = 0, e = comprimento; e> d; d ++) c = a [d], fc [c] = fc [c] || [], fc [c ] .unshift (b)}, pré-filtro: função (a, b) {b? ec.unshift (a): ec.push (a)}}), n.speed = function (a, b, c) {var d = a && "objeto" == tipo de a? n.extend ({}, a): {complete: c ||! c && b || n.isFunção (a) && a, duration: a, flexibilização: c && b || b &&! n.isFunção (b) & return d.duração = n.fx.off? 0: "número" == tipo de d.duração? d.duração: d.duração nas velocidades n.fx? n.fx. velocidades [d.duração]: n.fx.speeds._default, (null == fila de espera || fila de espera ===!0) && (d.queue = "fx"), d.old = d.complete, d.complete = function () {n.isFunção (d.old) && d.old.call (this), d.queue && n. dequeue (this, d.queue)}, d}, n.fn.extend ({fadeTo: function (a, b, c, d) {retorna this.filter (V) .css ("opacidade", 0). show (). end (). animate ({opacidade: b}, a, c, d)}, anima: função (a, b, c, d) {var e = n.isEmptyObject (a), f = n .speed (b, c, d), g = function () {var b = lc (this, n.extend ({}, a), f); (e || n._data (this, "finish")) ) && b.stop (! 0)}; retorne g.finish = g, e || f.queue ===! 1? this.each (g): this.queue (f.queue, g)}, pare: function (a, b, c) {var d = function (a) {var b = a.stop; delete a.stop, b (c)}; retorna "string"! = typeof a && (c = b, b = a, a = void 0), b && a! ==! 1 && this.queue (a || "fx", []), this.each (function () {var b =! 0, e = null! = a && a + "queueHooks ", f = n.timers, g = n._dados (isto); se (e) g [e] && g [e].stop && d (g [e]); caso contrário, para (e em g) g [e] && g [e] .para && dc.test (e) && d (g [e]); for (e = f.length; e--; ) f [e] .elem! == isto || nulo! = a && f [e]. fila! == a || (f [e] .anim.stop (c), b =! 1, f.splice ( e, 1)); (b ||! c) && n.dequeue (this, a)})}, finish: function (a) {return a! ==! 1 && (a = a || "fx"), this.each (function () {var b, c = n._data (this), d = c [a + "fila"], e = c [a + "queueHooks"], f = n.timers, g = d? d.length: 0; para (c.finish =! 0, n.queue (this, a, []), e && e.stop && e.stop.call (this,! 0), b = f.length; b-- ;) f [b] .elem === isso && f [b] .queue === a && (f [b] .anim.stop (! 0), f.splice (b, 1)); for (b = 0 ; g> b; b ++) d [b] && d [b] .finish && d [b] .finish.call (this); delete c.finish})}}), n.each (["alternar", "mostrar" , "ocultar"], função (a, b) {var c = n.fn [b]; n.fn [b] = função (a, d, e) {return null == a || "booleano "== tipo de a? c.apply (this, argumentos): this.animate (hc (b,! 0), a, d, e)}}), n.each ({slideDown: hc (" show " ), slideUp: hc ("ocultar"), slideToggle: hc ("alternar"), fadeIn: {opacidade: "show"}, fadeOut: {opacidade: "ocultar"}, fadeToggle: {opacidade: "alternar"}} , function (a, b) {n.fn [a] = function (a, c, d) {retorna this.animate (b, a, c, d)}}), n.timers = [], n. fx.tick = function () {var a, b = n.timers, c = 0; for (_b = n.now (); c <comprimento.b; c ++) a = b [c], a () | | b [c]! == a || b.splice (c -, 1); b.length || n.fx.stop (), _ b = void 0}, n.fx.timer = function (a ) {n.timers.push (a), a ()? n.fx.start (): n.timers.pop ()}, n.fx.interval = 13, n.fx.start = function () { ac || (ac = setInterval (n.fx.tick, n.fx.interval))}, n.fx.stop = function () {clearInterval (ac), ac = nulo}, n.fx.speeds = { lento: 600, rápido: 200, _default: 400}, n.fn.delay = function (a, b) {retorna a = n.fx? n.fx.speeds [a] || a: a, b = b || "fx", isso.fila (b, função (b, c) {var d = setTimeout (b, a); c.stop = function () {clearTimeout (d)}})}, function () {var a, b, c, d , e = z.createElement ("div"); e.setAttribute ("className", "t"), e.innerHTML = "<link/><table> </table> <a href='/a'> a </a> <input type = 'checkbox' /> ", a = e.getElementsByTagName (" a ") [0], c = z.createElement (" select "), d = c.appendChild (z.createElement ("opção")), b = e.getElementsByTagName ("entrada") [0], a.style.cssText = "top: 1px", l.getSetAttribute = "t"! == e.className, l.style = / top / .test (a.getAttribute ("estilo")), l.hrefNormalized = "/ a" === a.getAttribute ("href"), l.checkOn = !! b.value, l.optSelected = d.selected, l.enctype = !! z.createElement ("form"). enctype, c.disabled =! 0, l.optDisabled =! d.disabled,b = z.createElement ("entrada"), b.setAttribute ("valor", ""), l.input = "" === b.getAttribute ("valor"), b.valor = "t", b .setAttribute ("type", "radio"), l.radioValue = "t" === b.valor, a = b = c = d = e = null} (); var mc = / \ r / g; n.fn.extend ({val: function (a) {var b, c, d, e = this [0]; {if (argument.length) retorna d = n.isFunction (a), this.each (function (c) {var e; 1 === this.nodeType && (e = d? a.call (this, c, n (this) .val ()): a, null == e? e = "": " número "== tipo de e? e + =" ": n.isArray (e) && (e = n.map (e, função (a) {return null == a?" ": a +" "})), b = n.valHooks [this.type] || n.valHooks [this.nodeName.toLowerCase ()], b && "set" em b && void 0! == b.set (this, e, "value") || (this .value = e))}); if (e) retorne b = n.valHooks [e.type] || n.valHooks [e.nodeName.toLowerCase ()], b && "get" em b && void 0! == (c = b.get (e, "valor"))? c: (c = e.value, "string" == tipo de c? substituir (mc, ""): null == c? "": c)}}}), n.extend ({valHooks: {option: {get: function (a) {var b = n.find.attr (a , "valor"); retorne nulo! = b? b: n.text (a)}}, selecione: {get: function (a) {for (var b, c, d = a.options, e = a. selectedIndex, f = "selecionar um" === a.type || 0> e, g = f? null: [], h = f? e + 1: d.length, i = 0> e? h: f? e: 0; h> i; i ++) if (c = d [i],! (! c.selected && i! == e || (l.optDisabled? c.disabled: null! == c.getAttribute ( "desativado")) || c.parentNode.disabled && n.nodeName (c.parentNode, "optgroup")))) {if (b = n (c) .val (), f) return b; g.push (b) } return g}, set: function (a, b) {var c, d, e = a.options, f = n.makeArray (b), g = comprimento.length; while (g -) if (d = e [g], n.inArray (n.valHooks.option.get (d), f)> = 0) tente {d.selected = c =!0} catch (h) {d.scrollHeight} else d.selected =! 1; return c || (a.selectedIndex = -1), e}}}}), n.each (["radio", "checkbox "], function () {n.valHooks [this] = {set: function (a, b) {retorna n.isArray (b)? a.checked = n.inArray (n (a) .val (), b )> = 0: void 0}}, l.checkOn || (n.valHooks [this] .get = function (a) {return null === a.getAttribute ("value")? "On": a. valor})}); var nc, oc, pc = n.expr.attrHandle, qc = / ^ (?: marcado | selecionado) $ / i, rc = l.getSetAttribute, sc = l.input; n.fn. estender ({attr: função (a, b) {retornar W (isto, n.atr, a, b, argumentos.length> 1)}, removeAttr: função (a) {retornar this.each (function () {n .removeAttr (this, a)})}}), n.extend ({attr: function (a, b, c) {var d, e, f = a.nodeType; if (a && 3! == f && 8! == f && 2! == f) tipo de retorno de a.getAttribute === L? n.prop (a, b, c) :( 1 === f && n.isXMLDoc (a) || (b = b.toLowerCase (), d = n.attrHooks [b] || (n.expr.match.bool.teste (b)? oc: nc)), void 0 === c? d && "get" em d && null! == (e = d.get (a, b))? e: (e = n.find.attr (a, b), null == e? void 0: e): null! == c? d && "set" em d && void 0! == (e = d.set (a, c, b))? e: (a.setAttribute (b, c + ""), c): void n.removeAttr (a, b))}, removeAttr: função (a, b) {var c, d, e = 0, f = b &&b.match (F); if (f && 1 === a.nodeType) while (c = f [e ++]) d = n.propFix [c] || c, n.expr.match.bool.test (c)? Sc && rc | |! qc.test (c)? a [d] =! 1: a [n.camelCase ("padrão -" + c)] = a [d] =! 1: n.attr (a, c, "" ), a.removeAttribute (rc? c: d)}, attrHooks: {type: {set: function (a, b) {if (! l.radioValue && "radio" === b && n.nodeName (a, "input" )) {var c = a.value; retorna a.setAttribute ("tipo", b), c && (a.value = c), b}}}}}), oc = {set: function (a, b, c) {return b ===! 1? n.removeAttr (a, c): sc && rc ||! qc.test (c)? a.setAttribute (! rc && n.propFix [c] || c, c): a [n.camelCase ("padrão -" + c)] = a [c] =! 0, c}}, n.each (n.expr .match.bool.source.match (/ \ w + / g), função (a, b) {var c = pc [b] || n.find.attr; pc [b] = sc && rc ||! qc.test (b)? function (a, b, d) {var e, f; retorno d || (f = pc [b], pc [b] = e, e = nulo! = c (a, b, d) ? b.toLowerCase (): null, pc [b] = f), e}: function (a, b, c) {retornar c? void 0: a [n.camelCase ("padrão -" + b)]? b.toLowerCase (): null}}), sc && rc || (n.attrHooks.value = {set: function (a, b, c) {retorna n.nodeName (a, "entrada")? void (a.defaultValue = b): nc && nc.set (a, b, c)}}), rc || (nc = {conjunto: função (a, b, c) {var d = a.getAttributeNode (c); return d || a.setAttributeNode (d = a.ownerDocument.createAttribute (c)), d.value = b + = "", "valor" === c || b === a.getAttribute (c)? b: void 0} }, pc.id = pc.name = pc.coords = function (a, b, c) {var d; retorna c? void 0: (d = a.getAttributeNode (b)) &&""! == d.valor? d.value: null}, n.valHooks.button = {get: function (a, b) {var c = a.getAttributeNode (b); retornar c &&c.especificado? c.value : void 0}, set: nc.set}, n.attrHooks.contenteditable = {set: function (a, b, c) {nc.set (a, "" === b?! 1: b, c) }}, n.each (["width", "height"], função (a, b) {n.attrHooks [b] = {set: function (a, c) {return "" === c? ( a.setAttribute (b, "auto"), c): void 0}}})), l.style || (n.attrHooks.style = {get: function (a) {return a.style.cssText || vazio 0}, defina: função (a, b) {retorne a.style.cssText = b + ""}}); var tc = / ^ (?: entrada | selecione | área de texto | botão | objeto) $ / i, uc = / ^ (?: a | area) $ / i; n.fn.extend ({prop: function (a, b) {retorna W (este, n.prop, a, b, argumentos.length> 1)} , removeProp: função (a) {retorne a = n.propFix [a] || a, this.each (function () {experimente {this [a] = void 0, exclua esta [a]} captura (b) { }})}}), n.extend ({propFix: {"for":"htmlFor", "class": "className"}, prop: function (a, b, c) {var d, e, f, g = a.nodeType; if (a && 3! == g && 8! == g && 2! = = g) retorna f = 1! == g ||! n.isXMLDoc (a), f && (b = n.propFix [b] || b, e = n.propHooks [b]), nulo 0! == c? e && "set" em e && void 0! == (d = e.set (a, c, b))? d: a [b] = c: e && "get" em e && null! == (d = e. get (a, b))? d: a [b]}, propHooks: {tabIndex: {get: function (a) {var b = n.find.attr (a, "tabindex"); return b? parseInt ( b, 10): tc.test (a.nodeName) || uc.test (a.nodeName) && a.href? 0: -1}}}}), l.hrefNormalizado || n.each (["href" , "src"], função (a, b) {n.propHooks [b] = {get: function (a) {retorne a.getAttribute (b, 4)}}}), l.optSelected || (n. propHooks.selected = {get: function (a) {var b = a.parentNode; return b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex),null}}), n.each (["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"] , function () {n.propFix [this.toLowerCase ()] = this}), l.enctype || (n.propFix.enctype = "encoding"); var vc = / [\ t \ r \ n \ f ] /g;n.fn.extend ({addClass: function (a) {var b, c, d, e, f, g, h = 0, i = this.length, j = "string" == tipo de um && a ; if (n.isFunção (a)) retorna this.each (function (b) {n (this) .addClass (a.call (this, b, this.className))}); if (j) for (b) = (a || ""). match (F) || []; i> h; h ++) if (c = this [h], d = 1 === c.nodeType && (c.className? ("" + c.className + "") .replace (vc, ""): "")) {f = 0; while (e = b [f ++]) d.indexOf ("" + e + "") <0 && (d + = e + ""); g = n.trim (d), c.className! == g && (c.className = g)} retorne isso}, removeClass: function (a) {var b, c, d, e, f, g, h = 0, i = this.length, j = 0 === argumentos.length || "string" == tipo de a && a; if (n.isFunction (a)) retorna this.each (function (b) {n (this) .removeClass (a .call (this, b, this.className))}); if (j) for (b = (a || ""). match (F) || []; i> h; h ++) if (c = este [h], d = 1 === c.nodeType && (c.className? ("" + c.className + ""). substitua (vc, ""): "")) {f = 0; while (e = b [f ++]) while (d.indexOf ("" + e + "")>> 0) d = d. substituir ("" + e + "", ""); g = a? n.trim (d) : "", c.className! == g && (c.className = g)} retorne}, toggleClass: function (a, b) {var c = typeof a; return "boolean" == typeof b && "string" = == c? b? this.addClass (a): this.removeClass (a): this.each (n.isFunction (a)? function (c) {n (this) .toggleClass (a.call (this, c, this.className, b), b)}: function () {if ("string" === c) {var b, d = 0, e = n (isto), f = a.match (F) || []; while (b = f [d ++]) e.hasClass (b)? e.removeClass (b) : e.addClass (b)} else (c === L || "booleano" === c) && (this.className && n._data (este, "__ className __", this.className), this.className = this. className || a ===! 1? "": n._dados (este, "__ className __") || "")})}, hasClass: function (a) {for (var b = "" + a + "" , c = 0, d = this.length; d> c; c ++) if (1 === this [c] .nodeType && ("" + this [c] .className + ""). substitua (vc, "") .indexOf (b)> = 0) return! 0; return! 1}}), n.each ("desfoque foco foco foco foco carga carregamento redimensionar rolagem descarregar clique dblclick mouse com mouse mousemove mouseover mouseout mouseenter mouseousouseave mudança selecionar enviar tecla pressionada tecla pressionada keyup error contextmenu ".split (" "), function (a, b) {n.fn [b] = function (a , c) {return argument.length> 0? this.on (b, null, a, c): this.trigger (b)}}), n.fn.extend ({hover: function (a, b) { retorna this.mouseenter (a) .mouseleave (b || a)}, bind: function (a, b, c) {retorna this.on (a, null, b, c)}, unbind: function (a, b ) {return this.off (a, null, b)}, delega: function (a, b, c, d) {retorna this.on (b, a, c, d)}, desclassifica: function (a, b , c) {return 1 === argument.length? this.off (a, "**"): this.off (b, a || "**", c)}}); var wc = n. agora (), xc = / \? /, yc = / (,) | (\ [| {) | (} |]) | "(?: [^" \\\ r \ n] | \\ [" \\\ / bfnrt] | \\ u [\ da-fA-F] {4}) * "\ s * :? | true | false | null | -? (?! 0 \ d) \ d + (?: \. \ d + |) (?: [eE] [+ -]? \ d + |) / g; n.parseJSON = function (b) {if (a.JSON && a.JSON.parse) retorna a.JSON.parse (b + ""); var c, d = nulo, e = n.trim (b + ""); retorna e &&! n.trim (e. substituir (yc, função (a, b, e, f) {retornar c && b && (d = 0), 0 === d? a: (c = e || b, d + =! f- ! e, "")}))? Function ("return" + e) ​​(): n.error ("JSON inválido:" + b)}, n.parseXML = function (b) {var c, d; se (! b || "string"! = typeof b) return null; tente {a.DOMParser? (d = novo DOMParser, c = d.parseFromString (b, "text / xml")) :( c = new ActiveXObject ( "Microsoft.XMLDOM"), c.async = "false", c.loadXML (b))} captura (e) {c = void 0} retorna c && c.documentElement &&! C.getElementsByTagName ("parsererror"). Length || n.error ("XML inválido:" + b), c}; var zc, Ac, Bc = / #. * $ /, Cc = / ([? &]) _ = [^ &] * /, Dc = / ^ (. *?): [\ t] * ([^ \ r \ n] *) \ r? $ / gm, Ec = / ^ (?: sobre | app | armazenamento de aplicativos |.+ -extensão | arquivo | res | widget): $ /, Fc = / ^ (?: GET | HEAD) $ /, Gc = / ^ \ / \ //, Hc = / ^ ([\ w. + -] +:) (?: \ / \ / (?: [^ \ /? #] * @ |) ([^ \ /? #:] *) (? :: (\ d +) |) |) /, Ic = {}, Jc = {}, Kc = "* /". Concat ("*"); tente {Ac = location.href} captura (Lc) {Ac = z.createElement ("a"), Ac.href = "", Ac = Ac.href} zc = Hc.exec (Ac.toLowerCase ()) || []; function Mc (a) {return function (b, c) {"string"! = Typeof b && (c = b, b = "*"); var d, e = 0, f = b.toLowerCase (). match (F) || []; if (n.isFunction (c)) while (d = f [e ++ ]) "+" === d.charAt (0)? (d = d.slice (1) || "*", (a [d] = a [d] || []). unshift (c) ) :( a [d] = a [d] || []). push (c)}} função Nc (a, b, c, d) {var e = {}, f = a === Jc; função g (h) {var i; retornar e [h] =! 0, n.cada (a [h] || [], função (a, h) {var j = h (b, c, d); return "string"! = tipo de j || f || e [j]? f?! (i = j): void 0: (b.dataTypes.unshift (j), g (j) ,! 1)}) , i} retorna g (b.dataTypes [0]) ||! e ["*"] &&função g ("*")} Oc (a, b) {var c, d, e = n.ajaxSettings.flatOptions || {}; para (d em b) vazio 0! == b [d] && (( e [d]? a: c || (c = {})) [d] = b [d]); return c && n.extend (! 0, a, c), a} função Pc (a, b, c ) {var d, e, f, g, h = a.contents, i = a.dataTypes; while ("*" === i [0]) i.shift (), void 0 === e && (e = a.mimeType || b.getResponseHeader ("Tipo de conteúdo")); if (e) for (g em h) if (h [g] && h [g] .test (e)) {i.unshift (g ); break} if (i [0] em c) f = i [0]; caso contrário {para (g em c) {if (! i [0] || a.conversores [g + "" + i [0] ]) {f = g; break} d || (d = g)} f = f || d} retorna f? (f! == i [0] && i.unshift (f), c [f]): void 0} função Qc (a, b, c, d) {var e, f, g, h, i, j = {}, k = a.dataTypes.slice (); if (k [1]) para ( g em a.conversores) j [g.toLowerCase ()] = a.conversores [g]; f = k.shift (); while (f) if (a.responseFields [f] && (c [a.responseFields [ f]] = b) ,! i && d && a.dataFilter && (b = a.dataFilter (b, a.dataType)), i = f, f = k.shift ()) if ("*" === f) f = i; caso contrário, if ("*"! == i && i! == f) {if (g = j [i + "" + f] || j ["*" + f] ,! g) para (e em j) se (h = e.split ("")), h [1] === f && (g = j [i + "" + h [0]] || j ["*" + h [0]])) {g ===! 0? g = j [e]: j [e]! ==! 0 && (f = h [0], k.unshift (h [1])); break} if (g! ==! 0) if (g && a ["lança"]) b = g (b); caso contrário, tente { b = g (b)} catch (l) {return {state: "parsererror", erro: g? l: "Nenhuma conversão de" + i + "para" + f}}} retorna {state: "success", dados : b}} n.extend ({active: 0, lastModified: {}, etag: {}, ajaxSettings: {url: Ac, tipo: "GET", isLocal: Ec.test (zc [1]), global: ! 0, processData:! 0, assíncrono:! 0, contentType: "application / x-www-form-urlencoded; charset = UTF-8", aceita: {"*": Kc, text: "text / plain", html: "text / html", xml: "application / xml, text / xml ", json:" application / json, text / javascript "}, conteúdo: {xml: / xml /, html: / html /, json: / json /}, responseFields: {xml:" responseXML ", texto:" responseText ", json:" responseJSON "}, conversores: {" * text ": String," text html ":! 0," text json ": n.parseJSON," text xml ": n. parseXML}, flatOptions: {url:! 0, contexto:! 0}}, ajaxSetup: function (a, b) {return b? Oc (Oc (a, n.ajaxSettings), b): Oc (n.ajaxSettings, a)}, ajaxPrefilter: Mc (Ic), ajaxTransport: Mc (Jc), ajax: function (a, b) {"objeto" == tipo de a && (b = a, a = 0), b = b || (}; var c, d, e, f, g, h, i, j, k = n.ajaxSetup ({}, b), l = k.context || k, m = k.context && (l.nodeType || l.jquery)? n (l): n.event, o = n.Deferido (), p = n.Callbacks ("once memory"), q = k.statusCode || {}, r = {} , s = {}, t = 0, u = "cancelado", v = {readyState: 0, getResponseHeader:função (a) {var b; if (2 === t) {if (! j) {j = {}; while (b = Dc.exec (f)) j [b [1] .toLowerCase ()] = b [2]} b = j [a.toLowerCase ()]} retorna nulo == b? nulo: b}, getAllResponseHeaders: function () {return 2 === t? f: null}, setRequestHeader: function ( a, b) {var c = a.toLowerCase (); return t || (a = s [c] = s [c] || a, r [a] = b), isso}, overrideMimeType: function (a ) {return t || (k.mimeType = a), this}, statusCode: function (a) {var b; if (a) if (2> t) para (b in a) q [b] = [q [b], a [b]]; senão v.always (a [v.status]); retorne isso}, aborte: function (a) {var b = a || u; retorne i && i.abort (b), x (0, b), isso}}; if (o.promise (v) .complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a | | k.url || Ac) + ""). replace (Bc, ""). replace (Gc, zc [1] + "//"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = n.trim (k.dataType || "*"). toLowerCase (). match (F) || [""], null == k.crossDomain && (c = Hc.exec (k.url.toLowerCase ()), k.crossDomain =! (! c || c [1] === zc [1] && c [2] === zc [2] && (c [3] || ("http:" === c [1]? "80": "443")) === (zc [3] || ("http:" === zc [1]? "80": "443")))) ), k.data && k.processData && "string"! = tipo de k.data && (k.data = n.param (k.data, k. tradicional)), Nc (Ic, k, b, v), 2 === t) return v; h = k.global, h && 0 === n.active ++ && n.event.trigger ("ajaxStart"), k.type = k.type.toUpperCase (), k.hasContent =! Fc. teste (k.type), e = k.url, k.hasContent || (k.data && (e = k.url + = (xc.test (e)? "&": "?") + k.data, excluir k.data), k.cache ===! 1 && (k.url = Cc.test (e)? e.replace (Cc, "$ 1 _ =" + wc ++): e + (xc.test (e)? "&": "?") + "_ =" + wc ++)), k.ifModificado && (n.últimoModificado [e] && v.setRequestHeader ("If-Modified-Since ", n.lastModified [e]), n.etag [e] && v.setRequestHeader (" If-None-Match ", n.etag [e])), (k.data && k.hasContent && k.contentType ! ==! 1 || b.contentType) && v.setRequestHeader ("Tipo de conteúdo", k.contentType), v.setRequestHeader ("Aceitar", k.dataTypes [0] && k.accepts [k.dataTypes [0] ]? k.accepts [k.dataTypes [0]] + ("*"! == k.dataTypes [0]? "," + Kc + "; q = 0,01": ""): k.accepts ["* "]); para (d em k.headers) v.setRequestHeader (d, k.headers [d]); if (k.beforeSend && (k.beforeSend.call (l, v, k) ===! 1 | | 2 === t)) return v.abort (); u = "abortar"; for (d em {sucesso: 1, erro: 1, completo: 1}) v [d] (k [d]); if (i = Nc (Jc, k, b, v)) {v.readyState = 1, h && m.trigger ("ajaxSend", [v, k]), k.async && k.timeout> 0 && (g = setTimeout (função () {v.abort ("timeout ")}, k.timeout)); tente {t = 1, i.send (r, x)} catch (w) {if (! (2> t)) jogue w; x (-1, w) }} else x (-1, "No Transport"); function x (a, b, c, d) {var j, r, s, u, w, x = b; 2! == t && (t = 2 , g && clearTimeout (g), i = nulo 0, f = d || "", v.readyState = a> 0? 4: 0, j = a> = 200 && 300> a || 304 === a, c && (u = Pc (k, v, c)), u = Qc (k, u, v, j), j? (K.ifModified && (w = v.getResponseHeader ("Última modificação")), w && (n.lastModified [ e] = w), w = v.getResponseHeader ("etag"), w && (n.etag [e] = w)), 204 === a || "HEAD" === k.type? x = " nocontent ": 304 === a? x =" não modificado ":( x = u.state, r = u.data, s = u.error, j =! s)) :( s = x, (a || ! x) && (x = "erro", 0> a && (a = 0))), v.status = a, v.statusText = (b || x) + "", j? o.resolveWith (l, [r, x, v]): o.rejectWith (l, [v, x, s]), v.statusCode (q), q = nulo 0, h && m.trigger (j? "ajaxSuccess ":" ajaxError ", [v, k, j? r: s]), p.fireWith (l, [v, x]), h && (m.trigger (" ajaxComplete ", [v, k]), --n.active || n.event.trigger ("ajaxStop")))} retornar v}, getJSON: function (a, b, c) {retornar n.get (a, b, c, "json") }, getScript: function (a, b) {retorna n.get (a, void 0, b, "script")}}), n.each (["get", "post"], função (a, b ) {n [b] = função (a, c, d, e) {retorno n.isFunção (c) && (e = e || d, d = c, c = nulo 0), n.ajax ({url : a, type: b, dataType: e, data: c, sucesso: d})}}), n.each (["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", " ajaxSend "], função (a, b) {n.fn [b] = função (a) {retorne this.on (b, a)}}), n._evalUrl = função (a) {retorne n.ajax ( {url: a, digite: "GET", dataType: "script", assíncrono:! 1, global:! 1, "lança":! 0})}, n.fn.estender ({wrapAll: function (a) {if (n.isFunction (a)) retorna this.each (function (b) {n (this) .wrapAll (a.call (this, b))}); if ( this [0]) {var b = n (a, this [0] .ownerDocument) .eq (0) .clone (! 0); this [0] .parentNode && b.insertBefore (this [0]), b.map (function () {var a = this; while (a.firstChild && 1 === a.firstChild.nodeType) a = a.firstChild; retorne a}). append (this)} retorne}, wrapInner: function (a) {return this.each (n.isFunction (a)? function (b) {n (this) .wrapInner (a.call (this, b))}: function () {var b = n (this), c = b.contents (); c.length? c.wrapAll (a): b.append (a)})}, wrap: function (a) {var b = n.isFunção (a); retorne this.each (function (c) {n (this) .wrapAll (b? a.call (this, c): a)})}, desembrulhe: function () {retorna this.parent (). each (function () {n.nodeName (this, "body") || n (this) .placeWith (this.childNodes)}). end ()}}), n.expr.filters.hidden = function (a) {return a.offsetWidth <= 0 && a .offsetHeight <= 0 ||! l.reliableHiddenOffsets () && "none" === (a.style && a.style.display || n.css (a, "exibição"))}, n.expr.filters.visible = função (a) {return! n.expr.filters.hidden (a)}; var Rc = /% 20 / g, Sc = / \ [\] $ /, Tc = / \ r? \ n / g, Uc = / ^ (?: enviar | botão | imagem | redefinir | arquivo) $ / i, Vc = / ^ (?: entrada | selecionar | área de texto | keygen) / i; função Wc (a, b, c, d) { var e; if (n.isArray (b)) n.each (b, função (b, e) {c || Sc.test (a)? d (a, e): Wc (a + "[" + ( "object" == tipo de e? b: "") + "]", e, c, d)}); caso contrário, se (c || "objeto"! == n.type (b)) d (a, b); caso contrário, para (e em b) Wc (a + "[" + e + "]", b [e], c, d)} n.param = função (a, b) {var c, d = [] , e = function (a, b) {b = n.isFunção (b)? b (): null == b? "": b, d [comprimento.d] = encodeURIComponent (a) + "=" + encodeURIComponent (b)}; if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray (a) || a.jquery &&! n.isPlainObject (a)) n.each (a, function () {e (this.name, this.value)}); caso contrário, para (c em a) Wc (c , a [c], b, e); return d.join ("&"). replace (Rc, "+")}, n.fn.extend ({serialize: function () {return n.param (this .serializeArray ())}, serializeArray: function () {retorna this.map (function () {var a = n.prop (isto, "elementos"); retorna um? n.makeArray (a): this}). filter (function () {var a = this.type; retorna this.name &&! n (this) .is (": disabled") && Vc.test (this.nodeName) &&! Uc.test (a) && (this. verificado ||! X.test (a))}). map (function (a, b) {var c = n (this) .val (); return null == c? null: n.isArray (c)? n.map (c, função (a) {retornar {nome: b.name, valor: a.replace (Tc, "\ r \ n")}}): {nome: b.name, valor: c.replace (Tc, "\ r \ n")}}). Get ()}}), n.ajaxSettings.xhr = void 0! == a.ActiveXObject? Function () {return! This.isLocal && / ^ (get | post | head | put | delete | opções) $ / i.test (this.type) && $ c () || _c ()}: $ c; var Xc = 0, Yc = {} , Zc = n.ajaxSettings.xhr (); a.ActiveXObject && n (a) .on ("descarregar", função () {para (var a in Yc) Yc [a] (void 0,! 0)}), l .cors = !! Zc && "withCredentials" em Zc, Zc = l.ajax = !! Zc, Zc && n.ajaxTransport (função (a) {if (! a.crossDomain || l.cors) {var b; return {send () () () () () () () () () () () () () () () () () () () () () () () () () () () () () (). ), a.xhrFields) para (e em a.xhrFields) f [e] = a.xhrFields [e]; a.mimeType && f.overrideMimeType && f.overrideMimeType (a.mimeType), a.crossDomain || c ["X-Requested -With "] || (c [" Solicitado por X com "] =" XMLHttpRequest "); para (e em c) void 0! == c [e] && f.setRequestHeader (e, c [e] +" "); f.send (a.hasContent && a.data || nulo), b = função (c, e) {var h,i, j; if (b && (e || 4 === f.readyState)) if (excluir Yc [g], b = nulo 0, f.onreadystatechange = n.noop, e) 4! == f.readyState && f .abort (); else {j = {}, h = f.status, "string" == tipo de f.responseText && (j.text = f.responseText); tente {i = f.statusText} catch (k) { i = ""} h ||! a.isLocal || a.crossDomain? 1223 === h && (h = 204): h = j.text? 200: 404} j && d (h, i, j, f.getAllResponseHeaders ())}, a.async? 4 === f.readyState? setTimeout (b): f.onreadystatechange = Yc [g] = b: b ()}, abort: function () {b && b (void 0 ,! 0)}}}}); function $ c () {try {return a.XMLHttpRequest} catch (b) {}} function _c () {try {return new a.ActiveXObject ("Microsoft.XMLHTTP")} catch (b) {}} n.ajaxSetup ({aceita: {script: "texto / javascript, aplicativo / javascript, aplicativo / ecmascript, aplicativo / x-ecmascript"}, conteúdo: {script: / (?: java | ecma) script /}, conversores: {"script de texto":função (a) {return n.globalEval (a), a}}}), n.ajaxPrefilter ("script", função (a) {void 0 === a.cache && (a.cache =! 1), a .crossDomain && (a.type = "GET", a.global =! 1)}), n.ajaxTransport ("script", função (a) {if (a.crossDomain) {var b, c = z.head | | n ("head") [0] || z.documentElement; return {send: function (d, e) {b = z.createElement ("script"), b.async =! 0, a.scriptCharset && (b .charset = a.scriptCharset), b.src = a.url, b.onload = b.onreadystatechange = function (a, c) {(c ||! b.readyState || / loading | complete / .test (b .readyState)) && (b.onload = b.onreadystatechange = null, b.parentNode && b.parentNode.removeChild (b), b = nulo, c || e (200, "sucesso"))}, c.insertBefore (b , c.firstChild)}, abort: function () {b && b.onload (void 0,! 0)}}}}); var ad = [], bd = / (=) \? (? = & | $) | \? \? /; n.ajaxSetup ({jsonp: "retorno de chamada",jsonpCallback: function () {var a = ad.pop () || n.expando + "_" + wc ++; retorne isso [a] =! 0, a}}), n.ajaxPrefilter ("json jsonp", function ( b, c, d) {var e, f, g, h = b.jsonp! ==! 1 && (bd.test (b.url)? "url": "string" == tipo de b.data &&! (b .contentType || ""). indexOf ("application / x-www-form-urlencoded") && bd.test (b.data) && "data"); return h || "jsonp" === b.dataTypes [ 0]? (E = b.jsonpCallback = n.isFunction (b.jsonpCallback)? B.jsonpCallback (): b.jsonpCallback, h? B [h] = b [h]. Substituir (bd, "$ 1" + e ): b.jsonp! ==! 1 && (b.url + = (xc.test (b.url)? "&": "?") + b.jsonp + "=" + e), b.conversores ["script json "] = function () {return g || n.erro (e +" não foi chamado "), g [0]}, b.dataTypes [0] =" json ", f = a [e], a [ e] = função () {g = argumentos}, d.sempre (função () {a [e] = f, b [e] && (b.jsonpCallback = c.jsonpCallback, ad.push (e)), g && n.isFunção (f) && f (g [0]), g = f = vazio 0}), "script"): vazio 0}), n.parseHTML = função (a, b, c) {if (! a || "string"! = typeof a) return null; "boolean "== tipo de b && (c = b, b =! 1), b = b || z; var d = v.exec (a), e =! c && []; return d? [b.createElement (d [ 1])] :( d = n.buildFragment ([a], b, e), e && e.length && n (e) .remove (), n.merge ([], d.childNodes))}; var cd = n .fn.load; n.fn.load = function (a, b, c) {if ("string"! = tipo de a && cd) retorna cd.apply (this, argument); var d, e, f, g = this , h = a.indexOf (""); return h> = 0 && (d = a.slice (h, a.length), a = a.slice (0, h)), n.isFunção (b)? ( c = b, b = vazio 0): b && "objeto" == tipo de b && (f = "POST"), g.length> 0 && n.ajax ({url: a, tipo: f, dataType: "html ", dados: b}). done (função (a) {e = argumentos, g.html (d? n (" <div> ")). append (n.parseHTML (a)). find (d): a)}). complete (função c && (a, b) {g.each (c, e || [a.responseText, b, a])}), isso}, n.expr.filters.animated = function (a ) {return n.grep (n.timers, function (b) {return a === b.elem}). length}; var dd = a.document.documentElement; function ed (a) {return n.isWindow ( a)? a: 9 === a.nodeType? a.defaultView || a.parentWindow:! 1} n.offset = {setOffset: function (a, b, c) {var d, e, f, g, h, i, j, k = n.css (a, "posição"), l = n (a), m = {}; "estático" === k && (a.style.posição = "relativo"), h = l.offset (), f = n.css (a, "superior"), i = n.css (a, "esquerda"), j = ("absoluto" === k || "fixo" = == k) && n.inArray ("auto", [f, i])> - 1, j? (d = posição l (), g = d.top, e = d.left) :( g = parseFloat (f) || 0, e = parseFloat (i) || 0), n.is Função (b) &&(b = b.call (a, c, h)), null! = b.top && (m.top = b.top-h.top + g), null! = b.left && (m.left = b. left-h.left + e), "using" em b? b.using.call (a, m): l.css (m)}}, n.fn.extend ({offset: function (a) {if (argumentos.length) return void 0 === a? this: this.each (function (b) {n.offset.setOffset (this, a, b)}); var b, c, d = {top: 0 , left: 0}, e = this [0], f = e && e.ownerDocument; se (f) retornar b = f.documentElement, n.contains (b, e)? (tipo de e.getBoundingClientRect! == L && (d = e.getBoundingClientRect ()), c = ed (f), {top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0), à esquerda: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0)}): d}, position: function () {if (this [0]) {var a, b, c = {top: 0, left: 0 }, d = this [0]; retornar "fixo" === n.css (d, "posição")? b = d.getBoundingClientRect () :( a = this.offsetParent (), b = this.offset ( ), n.nodeName (a [0], "html") || (c = a.offset ()), c.top + = n.css (a [0], "borderTopWidth",! 0), c.left + = n.css (a [0], "borderLeftWidth",! 0)), {top: b.top-c.top-n. css (d, "marginTop",! 0), à esquerda: b.left-c.left-n.css (d, "marginLeft",! 0)}}}, offsetParent: function () {retorne this.map ( function () {var a = this.offsetParent || dd; while (a &&! n.nodeName (a, "html") && "static" === n.css (a, "posição")) a = a. offsetParent; return a || dd})}}), n.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, função (a, b) {var c = / Y / .test (b); n.fn [a] = função (d) {return W (esta função (a, d, e) {var f = ed (a); return void 0 === e? f? b in f? f [ b]: f.document.documentElement [d]: a [d]: void (f? f.scrollTo (c? n (f) .scrollLeft (): e, c? e: n (f) .scrollTop () ): a [d] = e)}, a, d, argument.length, null)}}), n.each (["top", "left"]], função (a, b) {n.cssHooks [ b] = Mb (l.pixelPosition,função (a, c) {return c? (c = Kb (a, b), Ib.test (c)? n (a) .position () [b] + "px": c): void 0}) }), n.each ({Height: "height", Width: "width"}, função (a, b) {n.each ({padding: "inner" + a, content: b, "": "outer "+ a}, função (c, d) {n.fn [d] = função (d, e) {var f = argumentos. comprimento && (c ||" booleano "! = tipo de d), g = c || (d ===! 0 || e ===! 0? "margin": "border"); return W (esta função (b, c, d) {var e; return n.isWindow (b)? b.document.documentElement ["cliente" + a]: 9 === b.nodeType? (e = b.documentElement, Math.max (b.body ["rolagem" + a], e ["rolagem" + a ], b.body ["deslocamento" + a], e ["deslocamento" + a], e ["cliente" + a])): void 0 === d? n.css (b, c, g) : n.style (b, c, d, g)}, b, f? d: nulo 0, f, nulo)}})}), n.fn.size = function () {retorna this.length}, n.fn.andSelf = n.fn.addBack, "função"== typeof define && define.amd && define ("jquery", [], função () {return n}); var fd = a.jQuery, gd = a. $; return n.noConflict = function (b) {return a. $ === n && (a. $ = gd), b && a.jQuery === n && (a.jQuery = fd), n}, tipo de b === L && (a.jQuery = a. $ = n), n} );